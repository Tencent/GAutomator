<!DOCTYPE html>
<html>
<head>
<title>GAutomator使用说明文档</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<p><a name="GAutomator"></a></p>
<h2>GAutomator Unity自动化测试教程</h2>
<ul>
<li><a href="#1">1 准备工作</a>
<ul>
<li><a href="#1.1">1.1 介绍</a></li>
<li><a href="#1.2">1.2 环境</a></li>
<li><a href="#1.3">1.3 使用脚本</a></li>
<li><a href="#1.4">1.4 GAutomatorView</a></li>
</ul>
</li>
<li><a href="#2">2 Getting</a>
<ul>
<li><a href="#2.1">2.1 Simple</a></li>
<li><a href="#2.2">2.2 实例详解</a></li>
<li><a href="#2.3">2.3 wetest云端兼容测试</a></li>
<li><a href="#2.4">2.4 本地运行</a></li>
</ul>
</li>
<li><a href="#3">3 Locating</a>
<ul>
<li><a href="#3.1">3.1 find_element</a></li>
<li><a href="#3.2">3.2 find_elements_path</a>
<ul>
<li><a href="#3.2.1">3.2.1 名称查找</a></li>
<li><a href="#3.2.2">3.2.2 子节点序列查找</a></li>
<li><a href="#3.2.3">3.2.3 节点中的图片名称查找</a></li>
<li><a href="#3.2.3">3.2.3 节点中的文字查找</a></li>
</ul>
</li>
<li><a href="#3.3">3.3 component名称查找</a></li>
<li><a href="#3.4">3.4 节点位置查找</a>
<ul>
<li><a href="#3.4.1">3.4.1 节点在屏幕上的位置</a></li>
<li><a href="#3.4.2">3.4.2 世界坐标获取</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4">4 交互</a>
<ul>
<li><a href="#4.1">4.1 点击操作</a></li>
<li><a href="#4.2">4.2 long</a></li>
<li><a href="#4.3">4.3 swipe滑动</a></li>
<li><a href="#4.4">4.4 input输入</a></li>
<li><a href="#4.5">4.5 弹出框处理(获取可交互节点)</a></li>
<li><a href="#4.6">4.6 获取文字内容</a></li>
<li><a href="#4.7">4.7 获取图片名称</a></li>
</ul>
</li>
<li><a href="#5">5 Mobile设备</a>
<ul>
<li><a href="#5.1">5.1 屏幕尺寸与转向</a></li>
<li><a href="#5.2">5.2 顶层Package与Activity</a></li>
<li><a href="#5.3">5.3 回退键</a></li>
</ul>
</li>
<li><a href="#6">6 云端报告</a>
<ul>
<li><a href="#6.1">6.1 截图与操作过程标记</a></li>
<li><a href="#6.2">6.2 截图</a></li>
<li><a href="#6.3">6.3 打标签</a></li>
</ul>
</li>
<li><a href="#7">7 定制功能</a>
<ul>
<li><a href="#7.1">7.1 Unity游戏端注册委托</a></li>
<li><a href="#7.2">7.2 脚本调用</a>
<ul>
<li><a href="#7.2.1">7.2.1 获取可执行委托</a></li>
<li><a href="#7.2.2">7.2.2 执行委托</a></li>
<li><a href="#7.2.3">7.2.3 获取组件上的方法</a></li>
<li><a href="#7.2.4">7.2.4 调用组件上的方法</a></li>
</ul>
</li>
<li><a href="#7.3">7.3 反射获取游戏中属性值</a></li>
<li><a href="#7.4">7.4 设置最佳渲染Camera</a></li>
<li><a href="#7.5">7.5 调用第三方C#脚本</a></li>
<li><a href="#7.6">7.6 C#脚本调用Python函数</a></li>
</ul>
</li>
<li><a href="#8">8 实战用例</a>
<ul>
<li><a href="#8.1">8.1 摇杆</a></li>
<li><a href="#8.2">8.2 记录操作流程</a></li>
<li><a href="#8.3">8.3 QQ或微信登录</a></li>
<li><a href="#8.4">8.4 战斗场景随机操作</a></li>
<li><a href="#8.5">8.5 选区操作</a></li>
<li><a href="#8.6">8.6 自动化探索遍历</a></li>
<li><a href="#8.7">8.7 异常处理</a></li>
</ul>
</li>
<li><a href="#9">9 实际使用接口</a>
<ul>
<li><a href="#9.1">9.1 screen_shot_click</a></li>
<li><a href="#9.2">9.2 screen_shot_click_pos</a></li>
<li><a href="#9.3">9.3 find_elment_wait查找控件直到出现位置</a></li>
<li><a href="#9.4">9.4 wait_for_scene等待某个场景加载完毕</a></li>
</ul>
</li>
</ul>
<p><strong>GAutomator</strong> 通过Python实现Unity手游的UI自动化测试，强烈建议使用pycharm编辑python。可在<a href="http://wetest.qq.com/cloud/index.php/phone/blrooike%E4%B8%8B%E8%BD%BD%E6%89%80%E6%9C%89%E9%9C%80%E8%A6%81%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%84%E4%BB%B6%E3%80%82" rel="nofollow">http://wetest.qq.com/cloud/index.php/phone/blrooike下载所有需要的所有组件。</a></p>
<p><a name="1"></a></p>
<h1>1 准备工作</h1>
<p><a name="1.1"></a></p>
<h2>1.1 介绍</h2>
<p>通过Python实现Unity手游的UI自动化测试。GAutomator测试运行在手机端，通过adb操控手机上的unity手游，支持所有版本的Android手机。这个工具的主要功能包括：测试与Android手机之间的兼容性--测试手游在不同Android手机上的工作情况。功能性测试，PVP游戏可以自动化测试代替人力节省操作，PVE游戏可以自动大关完成冒烟测试。性能测试，云端测试能够手机CPU、内存、流量和FPS数据，能够标记不同的场景。</p>
<p><a name="1.2"></a></p>
<h2>1.2 环境</h2>
<p><strong>1 python</strong>: python 2.7</p>
<p><strong>2 adb</strong><br>
请确保，你的path环境变量里面设置了adb<br>
在cmd命令行里面输入adb devices，能够看到你的手机序列号</p>
<p><a name="1.3"></a></p>
<h2>1.3 使用脚本</h2>
<p>如果使用pycharm的话，直接打开scripts功能即可进行编辑使用</p>
<p><a href="image/pycharm_step1.png" target="_blank"><img src="image/pycharm_step1.png" alt="Drawing" width="300px" style="max-width:100%;"></a></p>
<p><a href="image/pycharm_step2.png" target="_blank"><img src="image/pycharm_step2.png" alt="Drawing" width="300px" style="max-width:100%;"></a></p>
<p>可以在testcase目录下面直接创建你需要的.py脚本，然后编写需要的逻辑</p>
<p><a name="1.4"></a></p>
<h2>1.4 GAutomatorView</h2>
<p>GAutomatorView工具可在<a href="http://wetest.qq.com/cloud/index.php/phone/blrooike%E4%B8%8B%E8%BD%BD" rel="nofollow">http://wetest.qq.com/cloud/index.php/phone/blrooike下载</a> 。GAutomator主要根据，Unity游戏中的GameObject的路径名称来编写逻辑。类似于UIAutomator需要有一个，控件查看器；GAutomator也提供了一款类似的，Unity游戏中控件查看器。<br>
<strong>注：请勿将该软件放置在中文目录下</strong></p>
<p><a href="image/behaviour.png" target="_blank"><img src="image/behaviour.png" alt="Drawing" width="800px" style="max-width:100%;"></a></p>
<p>集成wetest sdk的游戏拉起后，点击同步按钮，就能获取到游戏界面和控件树</p>
<p><a name="2"></a></p>
<h1>2 Getting Started</h1>
<p>示例代码：sample/sample.py,示例apk游戏:sampel/wetest_demo.apk</p>
<p><a name="2.1"></a></p>
<h2>2.1 Simple Usage</h2>
<p>已经安装好python及依赖库后，可以使用pycharm（请下社区版，社区版免费）直接打开工程，你可以下面的代码开始我们的测试</p>
<div class="highlight highlight-source-python"><pre><span class="pl-c"><span class="pl-c">#</span>import lib path,only use in this demo</span>
<span class="pl-c"><span class="pl-c">#</span>import sys,os</span>
<span class="pl-c"><span class="pl-c">#</span>sys.path.append(os.path.abspath(os.path.join(os.getcwd(), "..\\")))</span>

<span class="pl-k">import</span> wpyscripts.manager <span class="pl-k">as</span> manager

<span class="pl-k">def</span> <span class="pl-en">test</span>():
    engine<span class="pl-k">=</span>manager.get_engine()
    logger<span class="pl-k">=</span>manager.get_logger()

    version<span class="pl-k">=</span>engine.get_sdk_version()
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Version Information : <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(version))

    scene<span class="pl-k">=</span>engine.get_scene()
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Scene :   <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(scene))

    sample_button<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/Sample<span class="pl-pds">"</span></span>)
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(sample_button))
    engine.click(sample_button)

test()
</pre></div>
<p>上面的代码可以保存为sample.py,然后运行</p>
<div class="highlight highlight-source-batchfile"><pre>python samle.py</pre></div>
<p>请确保，wetestdemo游戏已经拉起，wpyscripts库能够查找到</p>
<p><a name="2.2"></a></p>
<h2>2.2 实例详解</h2>
<p>wpyscripts.manager模块提供了自动化测试所需的所有功能，提供与引擎、手机、报告相关的内容，也提供了日志实现</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> wpyscripts.manager <span class="pl-k">as</span> manager</pre></div>
<p>下一步，创建Engine和日志实例</p>
<div class="highlight highlight-source-python"><pre>engine<span class="pl-k">=</span>manager.get_engine()
logger<span class="pl-k">=</span>manager.get_logger()</pre></div>
<p>*<code>engine.get_sdk_version()</code>*能够获取Unity版本信息、Wetest sdk版本信息，能够获取该信息时，证明脚本已经成功连上游戏。如果获取失败，则会抛出<code>WeTestNativeEngineDllError</code>异常,抛出该异常可能是手机USB线没有连好或者手机开发者选项未打开。<br>
*logger.debug("")*输出对应日志，请使用manager.get_logger()获取的实例，避免脚本在云端<a href="http://wetest.qq.com" title="wetest" rel="nofollow">wetest.qq.com</a>使用时出错。</p>
<div class="highlight highlight-source-python"><pre>version<span class="pl-k">=</span>engine.get_sdk_version()
logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Version Information : <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(version))</pre></div>
<p>*<code>engine.get_scene()</code>*获取当前游戏界面对应scene名称，wetestdemo游戏的第一个界面名称为main</p>
<p><a href="image/scene.png" target="_blank"><img src="image/scene.png" alt="Drawing" width="600px" style="max-width:100%;"></a></p>
<p>*<code>engine.find_element("/Canvas/Panel/Sample")</code>*查找当前界面中路径为/Canvas/Panel/Sample的节点，如果存在则返回Element，不存在则返回None。find_element直接使用Unity <a href="http://docs.unity3d.com/ScriptReference/GameObject.Find.html?from=index" rel="nofollow">GameObject.Find</a>查找当前游戏中的game object。<br>
查找到的节点samle_button（<em>Element</em>），有两个属性object_name,instance。object_name是节点的全路径，instance是节点实例的编号（GameObject.GetInstanceID()获取）instance在当前游戏中一定是唯一的。<br>
*<code>engine.click(sample_button)</code>*尝试点击samle_button这个GameObject的中心点。</p>
<div class="highlight highlight-source-python"><pre>sample_button<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/Sample<span class="pl-pds">"</span></span>)
logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(sample_button))
engine.click(sample_button)</pre></div>
<p>wpyscripts包含4大接口</p>
<div class="highlight highlight-source-python"><pre>engine<span class="pl-k">=</span>manager.get_engine()
reporter<span class="pl-k">=</span>manager.get_reporter()
device<span class="pl-k">=</span>manager.get_devcie()
logger<span class="pl-k">=</span>manager.get_logger()</pre></div>
<ul>
<li>engine:Unity相关内容，主要包括控件获取，游戏操作</li>
<li>reporter:云端报告相关，截图、标记操作过程、性能数据打标签</li>
<li>device:手机设备相关，如屏幕长宽高、转向，也包括QQ登录等。</li>
<li>logger:日志输出接口，保证本地与云端输出的日志都能获取到</li>
</ul>
<p><a name="2.3"></a></p>
<h2>2.3 wetest云端兼容测试</h2>
<p>wpyscripts编写好的测试脚本，只需要非常简单的修改，就能wetest云端上做兼容测试。云端几千台手机，按照脚本执行游戏。wetest能够发现兼容问题，同时高度还原执行现场，包括手机日志、崩溃信息、截图、执行过程等。</p>
<p>云端执行脚本时，会执行testcase.runner下的run函数，只需要把自己的业务逻辑加入到这个函数中即可</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> traceback

<span class="pl-k">try</span>:
    <span class="pl-k">from</span> sample.sample <span class="pl-k">import</span> <span class="pl-k">*</span>
<span class="pl-k">except</span> <span class="pl-c1">Exception</span>,e:
    traceback.print_exc()

<span class="pl-k">def</span> <span class="pl-en">run</span>():
    <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">        业务逻辑的起点</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
    <span class="pl-k">try</span>:
        test()
    <span class="pl-k">except</span> <span class="pl-c1">Exception</span>,e:
        traceback.print_exc()</pre></div>
<p>然后，运行scripts目录下的，build.py<br>
<code>python build.py</code><br>
会在scripts目录下产生一个,wpyscripts_upload.zip。只有企业用户才可以使用云端测试，请登录wetest.qq.com，联系工作人员了解详情。</p>
<p><a href="image/step1.png" target="_blank"><img src="image/step1.png" alt="Drawing" width="400px" style="max-width:100%;"></a></p>
<p><a href="image/step2.png" target="_blank"><img src="image/step2.png" alt="Drawing" width="400px" style="max-width:100%;"></a></p>
<p><a href="image/step3.png" target="_blank"><img src="image/step3.png" alt="Drawing" width="400px" style="max-width:100%;"></a></p>
<p><a name="2.4"></a></p>
<h2>2.4 本地运行</h2>
<p><strong>注：调试时手动启动游戏，运行到指定界面，运行对应的脚本即可，如调试大厅界面的代码，游戏跑到大厅界面，再运行自动化测试逻辑。不需要从main.py启动</strong><br>
GAutomator支持一台PC在多台android手机上同时测试。首先需要设置游戏的包名，在main.py开头处，进行修改设置local_package。</p>
<div class="highlight highlight-source-python"><pre>local_package <span class="pl-k">=</span> os.environ.get(<span class="pl-s"><span class="pl-pds">"</span>PKGNAME<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)  <span class="pl-c"><span class="pl-c">#</span> 你需要测试的包名,可以设置默认值</span>

<span class="pl-c"><span class="pl-c">#</span>local_package ="com.tencent.wetest.demo"</span></pre></div>
<p>一般一个工程通过main方式启动，只能测试一个游戏，所以直接在main.py里面写死，也避免参数传入的麻烦。<br>
1、测试一台手机，如果PC上USB只连接一台手机，直接启动main.py即可</p>
<div class="highlight highlight-source-batchfile"><pre>python main.py</pre></div>
<p>2、测试多台手机，如果PC上USB连接超过一台手机，需要通过命令行的方式启动</p>
<div class="highlight highlight-source-batchfile"><pre>adb devices #查看当前手机序列号

saaaweadf        device
asdfadfadf		 device
</pre></div>
<p>获取到当前PC连接的手机序列号之后，通过命令行的方式控制脚本在指定的手机上进行测试。</p>
<div class="highlight highlight-source-batchfile"><pre>python main.py --qqname=<span class="pl-c1">2952020110</span> --qqpwd=wetestpwd --engineport=<span class="pl-c1">50031</span> --uiport=<span class="pl-c1">19000</span> --serial=saaaweadf
python main.py --qqname=<span class="pl-c1">2952020111</span> --qqpwd=wetestpwd --engineport=<span class="pl-c1">50032</span> --uiport=<span class="pl-c1">19001</span> --serial=asdfadfadf</pre></div>
<p>上面的命令分别代表，在序列号"saaaweadf"手机上测试，测试时使用的QQ号为2952020110,密码为wetestpwd，与引擎建立映射的网络端口号为50031,与UIAutomator服务建立映射的网络端口为19000。第二条命令类似。</p>
<p><strong>命令行参数含义</strong>如下：</p>
<div class="highlight highlight-source-batchfile"><pre>--qqname:qq账号，每部手机应该都不一样
--qqpwd:qq密码
--wechataccount:微信账号
--wechatpwd:微信密码
--othername:其他任何账号
--otherpwd:其他任何账号的密码
--engineport:与手机端的sdk服务建立网络映射，填入的为本地的网络端口号（如,50031），不同手机之间要确保不同
--uiport:与手机端的UIAutomator服务建立网络映射，填入的为本地的网络端口号（如,19008），不同手机之间要确保不同
--serial:adb devcies能够查看手机的序列号，不同的序列号代表不同的手机</pre></div>
<p><a name="3"></a></p>
<h1>3 Locating Elements</h1>
<p>engine模块提供了三种GameObject的查找方式。示例：sample/find_elements.py</p>
<ul>
<li><em>find_element</em></li>
<li><em>find_elements_path</em></li>
<li><em>find_elements_by_component</em></li>
</ul>
<p><a name="3.1"></a></p>
<h2>3.1 find_element</h2>
<p><em>find_element</em>通过Unity的GameObject.Find()方法查找游戏中的的gameobject。<em>find_element</em>通过GameObject的名称查找对象，名字中可以包含'/'代表GameObject树中的一层。这方法只返回当前激活(active)的gameobject。<br>
当界面上有两个一模一样路径的gameobject时，只返回其中的一个。代码示例：</p>
<div class="highlight highlight-source-python"><pre><span class="pl-c"><span class="pl-c">#</span>import sys,os,time</span>
<span class="pl-c"><span class="pl-c">#</span>sys.path.append(os.path.abspath(os.path.join(os.getcwd(), "..\\")))</span>

<span class="pl-k">import</span> wpyscripts.manager <span class="pl-k">as</span> manager
<span class="pl-k">def</span> <span class="pl-en">test_find_element</span>():
    button<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/Button<span class="pl-pds">"</span></span>)
    bound<span class="pl-k">=</span>engine.get_element_bound(button)
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span>,Bound : <span class="pl-c1">{1}</span><span class="pl-pds">"</span></span>.format(button,bound))
    engine.click(button)

    button<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Button<span class="pl-pds">"</span></span>)
    bound<span class="pl-k">=</span>engine.get_element_bound(button)
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span>,Bound : <span class="pl-c1">{1}</span><span class="pl-pds">"</span></span>.format(button,bound))
    engine.click(button)

    button<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Panel/Button<span class="pl-pds">"</span></span>)
    bound<span class="pl-k">=</span>engine.get_element_bound(button)
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span>,Bound : <span class="pl-c1">{1}</span><span class="pl-pds">"</span></span>.format(button,bound))
    engine.click(button)

    unexited_gameobj<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Test<span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> unexited_gameobj <span class="pl-k">is</span> <span class="pl-c1">None</span>:
        logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Test GameObject not find<span class="pl-pds">"</span></span>)

test_find_element()</pre></div>
<p>上面的代码可以保存为find_elments.py,从wetestdemo点击FindElements，然后运行</p>
<div class="highlight highlight-source-batchfile"><pre>python find_elments.py</pre></div>
<p><a href="image/find_elements_scene.png" target="_blank"><img src="image/find_elements_scene.png" alt="Drawing" width="400px" style="max-width:100%;"></a></p>
<div class="highlight highlight-text-xml"><pre>&lt;<span class="pl-ent">GameObject</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>WetestSDK<span class="pl-pds">"</span></span> <span class="pl-e">components</span>=<span class="pl-s"><span class="pl-pds">"</span>U3DAutomationBehaviour<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>10064<span class="pl-pds">"</span></span> /&gt;
&lt;<span class="pl-ent">GameObject</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>Control<span class="pl-pds">"</span></span> <span class="pl-e">components</span>=<span class="pl-s"><span class="pl-pds">"</span>gobal<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>10074<span class="pl-pds">"</span></span> /&gt;
&lt;<span class="pl-ent">GameObject</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>EventSystem<span class="pl-pds">"</span></span> <span class="pl-e">components</span>=<span class="pl-s"><span class="pl-pds">"</span>EventSystem|StandaloneInputModule|TouchInputModule<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>10196<span class="pl-pds">"</span></span> /&gt;
&lt;<span class="pl-ent">GameObject</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>Canvas<span class="pl-pds">"</span></span> <span class="pl-e">components</span>=<span class="pl-s"><span class="pl-pds">"</span>Canvas|CanvasScaler|GraphicRaycaster|AudioListener<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>10188<span class="pl-pds">"</span></span>&gt;
  &lt;<span class="pl-ent">GameObject</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>bg<span class="pl-pds">"</span></span> <span class="pl-e">components</span>=<span class="pl-s"><span class="pl-pds">"</span>CanvasRenderer|Image<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>10198<span class="pl-pds">"</span></span> <span class="pl-e">img</span>=<span class="pl-s"><span class="pl-pds">"</span>Background<span class="pl-pds">"</span></span>&gt;
    &lt;<span class="pl-ent">GameObject</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>RawImage<span class="pl-pds">"</span></span> <span class="pl-e">components</span>=<span class="pl-s"><span class="pl-pds">"</span>CanvasRenderer|RawImage<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>10194<span class="pl-pds">"</span></span> <span class="pl-e">img</span>=<span class="pl-s"><span class="pl-pds">"</span>find_bg<span class="pl-pds">"</span></span> /&gt;
  &lt;/<span class="pl-ent">GameObject</span>&gt;
  &lt;<span class="pl-ent">GameObject</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>Panel<span class="pl-pds">"</span></span> <span class="pl-e">components</span>=<span class="pl-s"><span class="pl-pds">"</span>CanvasRenderer|FindElementsControl<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>10192<span class="pl-pds">"</span></span>&gt;
    &lt;<span class="pl-ent">GameObject</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>Button<span class="pl-pds">"</span></span> <span class="pl-e">components</span>=<span class="pl-s"><span class="pl-pds">"</span>CanvasRenderer|Image|Button|EventTriggerListener<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>10182<span class="pl-pds">"</span></span> <span class="pl-e">img</span>=<span class="pl-s"><span class="pl-pds">"</span>bt_bg<span class="pl-pds">"</span></span>&gt;
      &lt;<span class="pl-ent">GameObject</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>Text<span class="pl-pds">"</span></span> <span class="pl-e">components</span>=<span class="pl-s"><span class="pl-pds">"</span>CanvasRenderer|Text<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>10186<span class="pl-pds">"</span></span> <span class="pl-e">txt</span>=<span class="pl-s"><span class="pl-pds">"</span>Button<span class="pl-pds">"</span></span> /&gt;
    &lt;/<span class="pl-ent">GameObject</span>&gt;
    &lt;<span class="pl-ent">GameObject</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>Back<span class="pl-pds">"</span></span> <span class="pl-e">components</span>=<span class="pl-s"><span class="pl-pds">"</span>CanvasRenderer|Image|Back|EventTriggerListener<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>10190<span class="pl-pds">"</span></span> <span class="pl-e">img</span>=<span class="pl-s"><span class="pl-pds">"</span>back<span class="pl-pds">"</span></span> /&gt;
    &lt;<span class="pl-ent">GameObject</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>Button<span class="pl-pds">"</span></span> <span class="pl-e">components</span>=<span class="pl-s"><span class="pl-pds">"</span>CanvasRenderer|Image|Button<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>10200<span class="pl-pds">"</span></span> <span class="pl-e">img</span>=<span class="pl-s"><span class="pl-pds">"</span>bt_bg<span class="pl-pds">"</span></span>&gt;
      &lt;<span class="pl-ent">GameObject</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>Text<span class="pl-pds">"</span></span> <span class="pl-e">components</span>=<span class="pl-s"><span class="pl-pds">"</span>CanvasRenderer|Text<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>10184<span class="pl-pds">"</span></span> <span class="pl-e">txt</span>=<span class="pl-s"><span class="pl-pds">"</span>Button<span class="pl-pds">"</span></span> /&gt;
    &lt;/<span class="pl-ent">GameObject</span>&gt;
  &lt;/<span class="pl-ent">GameObject</span>&gt;
&lt;/<span class="pl-ent">GameObject</span>&gt;</pre></div>
<p>运行时符合"/Canvas/Panel/Button"的节点有两个，但是每次都是节点的第一个。如果查找的节点不存在，则返回None</p>
<p><a name="3.2"></a></p>
<h2>3.2 find_elements_path</h2>
<p><em>find_elements_path</em>能够一次查找到多个符合的gameobject。但是<em>find_elements</em>是一个<strong>非常耗时的操作需要谨慎使用</strong>，对测试时的性能数据有一定影响（主要是fps值）。<em>find_elments</em>通过表达式查找gameobject,查找条件为（查找条件为与，只要出现就一定要满足）：</p>
<ul>
<li>gameobject路径</li>
<li>gameobject在节点中的位置，顺序(第一个节点为0)</li>
<li>gameobject包含图片组件时的图片名称</li>
<li>gameobject包含文字组件时的文字内容<br>
<em><strong>注：不能确保返回结果的顺序</strong></em></li>
</ul>
<p><a name="3.2.1"></a></p>
<h3>3.2.1 名称查找</h3>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_find_elements_by_name</span>():
    elements <span class="pl-k">=</span> engine.find_elements_path(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/VerticalPanel/Item(Clone)<span class="pl-pds">"</span></span>)
    <span class="pl-k">for</span> element <span class="pl-k">in</span> elements:
        bound<span class="pl-k">=</span>engine.get_element_bound(element)
        logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span>,Bound : <span class="pl-c1">{1}</span><span class="pl-pds">"</span></span>.format(element,bound))
        engine.click(bound)
        time.sleep(<span class="pl-c1">0.5</span>)
test_find_elements_by_name()</pre></div>
<p>上面的代码可以保存为find_elments.py,从wetestdemo点击FindElements，然后运行</p>
<div class="highlight highlight-source-batchfile"><pre>python find_elments.py</pre></div>
<p><em>find_elements_path</em>能够返回所有符合的节点</p>
<p><a href="image/find_elments_xml.png" target="_blank"><img src="image/find_elments_xml.png" alt="Drawing" width="800px" style="max-width:100%;"></a></p>
<p>返回结果</p>
<div class="highlight highlight-text-xml"><pre>GameObject /Canvas/Panel/VerticalPanel/Item(Clone) Instance = -10080
GameObject /Canvas/Panel/VerticalPanel/Item(Clone) Instance = -10104
GameObject /Canvas/Panel/VerticalPanel/Item(Clone) Instance = -10128
GameObject /Canvas/Panel/VerticalPanel/Item(Clone) Instance = -10152
GameObject /Canvas/Panel/VerticalPanel/Item(Clone) Instance = -10176</pre></div>
<p>关卡列表，除了*/Canvas/Panel/VerticalPanel/Item(Clone)*符合之外，也可以是其他表达式。</p>
<div class="highlight highlight-source-python"><pre>_elements <span class="pl-k">=</span> engine.find_elements_path(<span class="pl-s"><span class="pl-pds">"</span>Panel/VerticalPanel/Item(Clone)<span class="pl-pds">"</span></span>)
_elements <span class="pl-k">=</span> engine.find_elements_path(<span class="pl-s"><span class="pl-pds">"</span>VerticalPanel/Item(Clone)<span class="pl-pds">"</span></span>)
_elements <span class="pl-k">=</span> engine.find_elements_path(<span class="pl-s"><span class="pl-pds">"</span>Item(Clone)<span class="pl-pds">"</span></span>)
_elements <span class="pl-k">=</span> engine.find_elements_path(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/*/Item(Clone)<span class="pl-pds">"</span></span>)</pre></div>
<ul>
<li><code>Panel/VerticalPanel/Item(Clone)</code>，表示查找节点Item(Clone)，且父亲节点为VerticalPanel，祖父节点Panel</li>
<li><code>VerticalPanel/Item(Clone)</code>，表示查找节点Item(Clone)，且父亲节点为VerticalPanel</li>
<li><code>Item(Clone)</code>，表示查找所有名叫Item(Clone)的节点</li>
<li><code>/Canvas/Panel/*/Item(Clone)</code>，表示查找节点Item(Clone)，任意父亲节点，祖父节点为Panel,曾祖父节点为Canvas且为根节点。其中*表示任意名称。</li>
</ul>
<p>***find_elments_path***接口非常耗时。</p>
<p><a name="3.2.2"></a></p>
<h3>3.2.2 子节点序列查找</h3>
<p>如果只想选择关卡2，不想返回所有的节点。可以利用<em>find_elements_path</em>中的序列来进行查找定位。序列的表达式为[num],num为数字从0开始</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_find_elements_by_index</span>():
    elements <span class="pl-k">=</span> engine.find_elements_path(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/VerticalPanel/*[1]<span class="pl-pds">"</span></span>)
    <span class="pl-k">for</span> element <span class="pl-k">in</span> elements:
        bound<span class="pl-k">=</span>engine.get_element_bound(element)
        logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span>,Bound : <span class="pl-c1">{1}</span><span class="pl-pds">"</span></span>.format(element,bound))
        engine.click(bound)
        time.sleep(<span class="pl-c1">0.5</span>)

    elements<span class="pl-k">=</span>engine.find_elements_path(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/VerticalPanel/Button[0]<span class="pl-pds">"</span></span>)
    <span class="pl-k">assert</span> elements <span class="pl-k">==</span> []
test_find_elements_by_index()</pre></div>
<p>上面的代码可以保存为find_elments.py,从wetestdemo点击FindElements，然后运行</p>
<div class="highlight highlight-source-batchfile"><pre>python find_elments.py</pre></div>
<p><em>find_elements_path</em>能够返回所有符合的节点,这个脚本中会返回关卡2，并进行点击</p>
<ul>
<li>/Canvas/Panel/VerticalPanel/*[1]，表示查找VericalPanel节点中的第二个子节点，VericalPanel的父节点为Panel,Panel的父节点为Cavnvas，且Canvas为根节点</li>
<li>/Canvas/Panel/VerticalPanel/Button[0]，表示查找VericalPanel节点中第一个子节点，<strong>且名为Button</strong>,VericalPanel的父节点为Panel,Panel的父节点为Cavnvas，且Canvas为根节点<br>
<strong>注：序列从0开始，0表示第一个子节点；序列[num]与名字的关系是与，需要都符合，如果是任意名称请用</strong>*。根节点不能使用[]，[]是相对于父亲节点的位置，所以根节点不存在父节点。</li>
</ul>
<p><a name="3.2.3"></a></p>
<h3>3.2.3 节点中的图片名称查找</h3>
<p><em>find_elements_path</em>能够根据节点的图片名称进行查找。表达式为{img=imageName}，img为图片名称</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_find_elements_by_img</span>():
    elements <span class="pl-k">=</span> engine.find_elements_path(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/Image{img=saturn}<span class="pl-pds">"</span></span>)
    <span class="pl-k">for</span> element <span class="pl-k">in</span> elements:
        bound<span class="pl-k">=</span>engine.get_element_bound(element)
        logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span>,Bound : <span class="pl-c1">{1}</span><span class="pl-pds">"</span></span>.format(element,bound))
        engine.click(bound)
        time.sleep(<span class="pl-c1">0.5</span>)
    engine.click_position(<span class="pl-c1">100</span>,<span class="pl-c1">200</span>)
    elements <span class="pl-k">=</span> engine.find_elements_path(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel{img=saturn}<span class="pl-pds">"</span></span>)
    <span class="pl-k">for</span> element <span class="pl-k">in</span> elements:
        bound<span class="pl-k">=</span>engine.get_element_bound(element)
        logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span>,Bound : <span class="pl-c1">{1}</span><span class="pl-pds">"</span></span>.format(element,bound))
test_find_elements_by_img()</pre></div>
<p>上面的代码可以保存为find_elments.py,从wetestdemo点击FindElements，然后运行</p>
<div class="highlight highlight-source-batchfile"><pre>python find_elments.py</pre></div>
<p><a href="image/find_elments_xml_img.png" target="_blank"><img src="image/find_elments_xml_img.png" alt="Drawing" width="800px" style="max-width:100%;"></a></p>
<p>运行结果如下，*/Canvas/Panel/Image{img=saturn}<em>和</em>/Canvas/Panel{img=saturn}*均能找到指定的节点</p>
<div class="highlight highlight-text-xml"><pre>Button : GameObject /Canvas/Panel/Image Instance = 10218,Bound : point(1461.0,81.0) width = 352.0 height = 341.0
Button : GameObject /Canvas/Panel Instance = 10222,Bound : point(0.0,0.0) width = 1920.0 height = 1080.5</pre></div>
<ul>
<li><code>/Canvas/Panel/Image{img=saturn}</code>,表示查找Image节点（且Image节点或者子节点包含saturn图片），Image父节点为Panel,Panel父节点为Canvas,且Canvas为根节点</li>
<li><code>/Canvas/Panel{img=saturn}</code>,表示查找Panel节点（且Panel节点或者子节点包含saturn图片）,Panel父节点为Canvas,且Canvas为根节点</li>
</ul>
<p>img代表的是图片名称，Unity游戏中哪些组件符合这边的名称呢？</p>
<ul>
<li>UGUI,wetest sdk会搜索Image、RawImage、SpriteRender中的图片</li>
<li>NGUI，wetest sdk会搜索UISprite、UITexture、Renderer中的图片</li>
</ul>
<p>为什么要搜索节点及其所有子节点？Unity制作的时候，往往会在可交互节点下面挂载图片文字等。这样做的目的是为了尽可能测试人员方便查找。</p>
<p><a name="3.2.3"></a></p>
<h3>3.2.3 节点中的文字查找</h3>
<p><em>find_elements_path</em>能够根据节点及子节点中文字内容进行查找。表达式为{txt=txtName}，txtName为文字内容</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_find_elements_by_txt</span>():
    elements<span class="pl-k">=</span>engine.find_elements_path(<span class="pl-s"><span class="pl-pds">"</span>Panel/VerticalPanel/Item(Clone){txt=关卡2}<span class="pl-pds">"</span></span>)
    <span class="pl-k">for</span> element <span class="pl-k">in</span> elements:
        bound<span class="pl-k">=</span>engine.get_element_bound(element)
        logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span>,Bound : <span class="pl-c1">{1}</span><span class="pl-pds">"</span></span>.format(element,bound))
        engine.click(bound)
        time.sleep(<span class="pl-c1">0.5</span>)

    elements<span class="pl-k">=</span>engine.find_elements_path(<span class="pl-s"><span class="pl-pds">"</span>Panel/VerticalPanel/Item(Clone){txt=关卡4}<span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> <span class="pl-c1">len</span>(elements) <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>:
        engine.click(elements[<span class="pl-c1">0</span>])
test_find_elements_by_txt()</pre></div>
<p>上面的代码可以保存为find_elments.py,从wetestdemo点击FindElements，然后运行</p>
<div class="highlight highlight-source-batchfile"><pre>python find_elments.py</pre></div>
<p><a href="image/find_elments_xml_txt.png" target="_blank"><img src="image/find_elments_xml_txt.png" alt="Drawing" width="600px" style="max-width:100%;"></a></p>
<p>运行结果如下，*Item(Clone){txt=关卡2}<em>和</em>Panel/VerticalPanel/Item(Clone){txt=关卡4}*均能找到指定的节点</p>
<div class="highlight highlight-text-xml"><pre>Button : GameObject /Canvas/Panel/VerticalPanel/Item(Clone) Instance = -11784,Bound : point(1420.0,710.5) width = 500.0 height = 80.0
Button : GameObject /Canvas/Panel/VerticalPanel/Item(Clone) Instance = -11832,Bound : point(1420.0,870.5) width = 500.0 height = 80.0</pre></div>
<ul>
<li><code>Panel/VerticalPanel/Item(Clone){txt=关卡2}</code>,表示查找Item(Clone)节点（且Item(Clone)节点或者其子节点，包含文字"关卡2"），Item(Clone)父节点为Panel,Panel父节点为Canvas,且Canvas为根节点</li>
<li><code>Panel/VerticalPanel/Item(Clone){txt=关卡4}</code>,表示查找Item(Clone)节点（且Item(Clone)节点或者其子节点，包含文字"关卡4"），Item(Clone)父节点为Panel,Panel父节点为Canvas,且Canvas为根节点</li>
</ul>
<p>txt代表的是文字内容，寻找匹配时，会从以下节点查找问题内容</p>
<ul>
<li>UGUI，wetest sdk会搜索组件Text、GUIText中的内容</li>
<li>NGUI，wetest sdk会搜索组件UILabel、UIInput和GUIText中的内容</li>
</ul>
<p><a name="3.3"></a></p>
<h2>3.3 component名称查找</h2>
<p>根据Unity中Component的名称查找，Gameobject。本质上调用的是Unity中的GameObject.FindObjectsOfType(Type.GetType(name))接口。C#里面Type.GetType传入的，应该是AssemblyQualifiedName。所以，下面的例子中传入的是"UnityEngine.UI.Button,UnityEngine.UI, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null"，如果传入的是Button返回为空</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_find_elements_by_component</span>():
    elements<span class="pl-k">=</span>engine.find_elements_by_component(<span class="pl-s"><span class="pl-pds">"</span>UnityEngine.UI.Button,UnityEngine.UI, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null<span class="pl-pds">"</span></span>)
    <span class="pl-k">for</span> element <span class="pl-k">in</span> elements:
        bound <span class="pl-k">=</span> engine.get_element_bound(element)
        logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span>,Bound : <span class="pl-c1">{1}</span><span class="pl-pds">"</span></span>.format(element, bound))
        engine.click(bound)
        time.sleep(<span class="pl-c1">0.5</span>)

test_find_elements_by_component()</pre></div>
<p><a name="3.4"></a></p>
<h2>3.4 节点位置查找</h2>
<p><a name="3.4.1"></a></p>
<h3>3.4.1 节点在屏幕上的位置</h3>
<p>*engine.get_element_bound(element)*能够获取节点在屏幕中的位置。wpyscripts所有的操作都是通过触屏进行的，因此获取节点在屏幕上的位置是进行交互操作的基石。</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_click</span>():
    <span class="pl-c"><span class="pl-c">#</span>点击节点</span>
    element<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/Click<span class="pl-pds">"</span></span>)
    bound<span class="pl-k">=</span>engine.get_element_bound(element)
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span>,Bound : <span class="pl-c1">{1}</span><span class="pl-pds">"</span></span>.format(element,bound))

    engine.click(bound)
    time.sleep(<span class="pl-c1">1</span>)
    engine.click(element)

    time.sleep(<span class="pl-c1">2</span>)
    engine.click_position(<span class="pl-c1">600.0</span>,<span class="pl-c1">100.0</span>)

test_click()</pre></div>
<pre><code>Button : GameObject /Canvas/Panel/Click Instance = 10652,Bound : point(535.0,60.0) width = 250.0 height = 80.0
</code></pre>
<p><code>engine.get_element_bound(Element)</code>获取的是ElementBound，获取Element的左上角在屏幕上的坐标，和Element的长宽高。遵循的是手机的坐标系，以左上角为坐标原点，上下边框为width，左右为height。</p>
<p><a href="image/interaction_click.png" target="_blank"><img src="image/interaction_click.png" alt="Drawing" width="400px" style="max-width:100%;"></a></p>
<p><a href="image/portrait.png" target="_blank"><img src="image/portrait.png" alt="Drawing" width="300px" style="max-width:100%;"></a></p>
<p><a name="3.4.2"></a></p>
<h3>3.4.2 世界坐标获取</h3>
<p>手游越来越重度化，3D手游越来越普及，对于3D手游而言仅仅是屏幕坐标已经无法满足自动化测试的需求。对于王者荣耀、全民超神这种类型的手游，自动化测试过程中需要知道自己、敌方和队友英雄在地图上的位置，才能编写出想要的自动化功能（如移动英雄到某个位置、发现敌方英雄攻击等）。所以在wpyscripts v 1.1.1版本，WeTest SDK 8版本，推出了get_element_world_bound(elements)，能够获取节点的世界坐标系。<strong>示例位置sample/joystick_tester.py 中的test_world_bounds()</strong></p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_world_bounds</span>():
    person<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>/3rd Person Controller/Bip001/Bip001 Pelvis<span class="pl-pds">"</span></span>)
    world_bound<span class="pl-k">=</span>engine.get_element_world_bound(person)
    logger.debug(world_bound[<span class="pl-c1">0</span>])

test_world_bounds()</pre></div>
<p>以上代码，需要在wetest_demo.apk点击Joystick，进入Joystick界面后运行才有效</p>
<div class="highlight highlight-source-batchfile"><pre>python joystick_tester.py</pre></div>
<p>结果如下：</p>
<div class="highlight highlight-text-xml"><pre>center = (5.03773808305e-05,0.1374322474,0.00151373702101) extents =(0.0807622969151,0.09486310184,0.0181320905685)</pre></div>
<p>返回查询的所有Element的对应世界坐标，WorldBound[]。WorldBound是节点在Unity世界坐标系中的各项值，主要包括中心点的x,y,z坐标值，及中心点距物体在x,y,z轴方向上的距离。具体可参考：Unity官网Bounds介绍<a href="http://docs.unity3d.com/ScriptReference/Bounds.html" rel="nofollow">http://docs.unity3d.com/ScriptReference/Bounds.html</a></p>
<p><a name="4"></a></p>
<h1>4 交互</h1>
<p>找到节点后的第一件后，就需要对寻找到的节点进行操作。示例：sample/interaction.py</p>
<div class="highlight highlight-source-python"><pre>engine.click(button)</pre></div>
<p>Engine执行操作后，会立马返回，不会等button按钮相应完成才返回。engine.click(Element)返回为True的话，只保证执行了button中心点的点击事件，不能确保button对应的事件被有效执行（有弹出框，遮住的情况就可能使点击无效）。</p>
<p><a href="image/interaction_mask.png" target="_blank"><img src="image/interaction_mask.png" alt="Drawing" width="400px" style="max-width:100%;"></a></p>
<p><a name="4.1"></a></p>
<h2>4.1 点击操作</h2>
<p>*engine.click()*允许传入Element和ElementBound。如果传入的是Element，会先去查找ElementBound,然后再计算出节点的中心位置进行点击。所以，在有ElementBound的情况下，应该首先传入ElementBound。</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_click</span>():
    <span class="pl-c"><span class="pl-c">#</span>点击节点</span>
    element<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/Click<span class="pl-pds">"</span></span>)
    bound<span class="pl-k">=</span>engine.get_element_bound(element)
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span>,Bound : <span class="pl-c1">{1}</span><span class="pl-pds">"</span></span>.format(element,bound))

    engine.click(bound)
    time.sleep(<span class="pl-c1">1</span>)
    engine.click(element)

    time.sleep(<span class="pl-c1">2</span>)
    engine.click_position(<span class="pl-c1">600.0</span>,<span class="pl-c1">100.0</span>)

test_click()</pre></div>
<p>上面的代码可以保存为interaction.py,从wetestdemo点击Interaction，然后运行</p>
<div class="highlight highlight-source-batchfile"><pre>python interaction.py</pre></div>
<p>程序会连续点击3下，Click按钮。</p>
<ul>
<li><code>engine.click(bound)</code>会点击，Click的中心节点(point.x+withd/2,point.y+height/2)</li>
<li><code>engine.click(element)</code>首先回去查找element节点的ElementBound，然后计算出中心点，在进行点击</li>
<li><code>engine.click_position(600.0,100.0)</code>直接点击屏幕坐标为(600.0,100.0)的坐标。<strong>手机屏幕尺寸发生变化，点击将无效，不能点击到期望位置</strong></li>
</ul>
<p><a name="4.2"></a></p>
<h2>4.2 long press长按</h2>
<p><em>engine.press()和engine.press_position</em>与click相似，多一个时间参数，表示长按的时间（单位ms,毫秒）</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_press</span>():
    element<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/Press<span class="pl-pds">"</span></span>)
    engine.press(element,<span class="pl-c1">5000</span>)
    time.sleep(<span class="pl-c1">2</span>)
    engine.press_position(<span class="pl-c1">1200</span>,<span class="pl-c1">100</span>,<span class="pl-c1">3000</span>)
    
test_press()</pre></div>
<p>上面的代码可以保存为interaction.py,从wetestdemo点击Interaction，然后运行</p>
<div class="highlight highlight-source-batchfile"><pre>python interaction.py</pre></div>
<ul>
<li><code>engine.press(element,5000)</code>,<code>/Canvas/Panel/Press</code>节点连续按住5s</li>
<li><code>ngine.press_position(1200,100,3000)</code>,(1200,100)点，连续按住3s</li>
</ul>
<p><a name="4.3"></a></p>
<h2>4.3 swipe滑动</h2>
<p><em>engine.swipe(start_element, end_element, steps, duration=1000)和engine.swipe_position(start_x,start_y,end_x,end_y,steps, duration=1000)</em>，可以从一个节点滑动到另外一个节点，通过设置滑动步骤来控制滑动的平滑度和滑动速度。duration以毫秒为单位，为滑动的时长。滑动时长不能不能精确控制，只是尽可能接近。滑动由Touch触屏操作的Down-&gt;move-&gt;move...-&gt;up组合而成，steps指的是move的数量，一般指的是滑动的平滑度。<em>swipe与swipe_position</em>动作执行完之后返回，由SDK负责执行动作，不能并行的执行动作。如下面的示例中，第一个动作执行完后，才会执行第二个动作。</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_swipe</span>():
    start_e<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/Press<span class="pl-pds">"</span></span>)
    end_e<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/Click<span class="pl-pds">"</span></span>)
    engine.swipe(start_e,end_e,<span class="pl-c1">50</span>,<span class="pl-c1">2000</span>)

    silder<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/Slider<span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> silder:
        bound<span class="pl-k">=</span>engine.get_element_bound(silder)
        engine.swipe_position(bound.x,bound.y<span class="pl-k">+</span>bound.height<span class="pl-k">/</span><span class="pl-c1">2.0</span>,bound.x<span class="pl-k">+</span>bound.width,bound.y<span class="pl-k">+</span>bound.height<span class="pl-k">/</span><span class="pl-c1">2</span>,<span class="pl-c1">100</span>,<span class="pl-c1">3000</span>)
test_swipe()</pre></div>
<p>上面的代码可以保存为interaction.py,从wetestdemo点击Interaction，然后运行</p>
<div class="highlight highlight-source-batchfile"><pre>python interaction.py</pre></div>
<p>从Press的中心点按钮按下，一直Move到Click的中心点，中间经过50步，最后执行Up动作，持续时长大致为2秒</p>
<pre><code>start_e=engine.find_element("/Canvas/Panel/Press")
end_e=engine.find_element("/Canvas/Panel/Click")
engine.swipe(start_e,end_e,50,2000)
</code></pre>
<p>无论swipe的步长设置为多少，都会立刻返回。立刻执行swipe_position函数，swipe_position也需要动作执行完之后才会返回，但是游戏中还不会马上执行这个动作。需要swipe执行完成后，才会执行swipe_position的动作。</p>
<pre><code>silder=engine.find_element("/Canvas/Panel/Slider")
if silder:
   bound=engine.get_element_bound(silder)
   engine.swipe_position(bound.x,bound.y+bound.height/2.0,bound.x+bound.width,bound.y+bound.height/2,100,3000)
</code></pre>
<p><a name="4.4"></a></p>
<h2>4.4 input输入</h2>
<p>*engine.input(Element,txt)*设置input里面的文字内容</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_input</span>():
    element<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/InputField<span class="pl-pds">"</span></span>)
    engine.input(element,<span class="pl-s"><span class="pl-pds">"</span>Run Wpy<span class="pl-pds">"</span></span>)

test_input()</pre></div>
<p>上面的代码可以保存为interaction.py,从wetestdemo点击Interaction，然后运行</p>
<div class="highlight highlight-source-batchfile"><pre>python interaction.py</pre></div>
<p>运行后，文本框里面的内容从<em>Hello wpyscripts</em>变成<em>Run Wpy</em>。</p>
<ul>
<li>UGUI,Element必须包含InputField组件</li>
<li>NGUI，Element必须包含UILabel组件</li>
</ul>
<p><a name="4.5"></a></p>
<h2>4.5 弹出框处理(获取可交互节点)</h2>
<p>所有的交互操作，只能保证屏幕上有这些时间。列如下图，点击Click按钮，只确保在屏幕Click按钮的位置按了一下，不确保Click按钮有效果，因为这个时候有弹出框遮住了Click按钮。<br>
<a href="image/interaction_mask.png" target="_blank"><img src="image/interaction_mask.png" alt="Drawing" width="400px" style="max-width:100%;"></a><br>
游戏运行过程中，因为等级、公告、网络等各种原因可能会出现弹出框，这个时候原本的测试逻辑将无法继续运行。engine.get_touchable_elements()可以返回当前可点击的节点。</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_get_touchable_elements</span>():
    e<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/Close<span class="pl-pds">"</span></span>)
    engine.click(e)

    elements<span class="pl-k">=</span>engine.get_touchable_elements()
    <span class="pl-k">for</span> e,pos <span class="pl-k">in</span> elements:
        logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span>,Bound : <span class="pl-c1">{1}</span><span class="pl-pds">"</span></span>.format(e,pos))

    time.sleep(<span class="pl-c1">2</span>)
    engine.click_position(elements[<span class="pl-c1">0</span>][<span class="pl-c1">1</span>][<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>],elements[<span class="pl-c1">0</span>][<span class="pl-c1">1</span>][<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>])

test_get_touchable_elements()</pre></div>
<p>上面的代码可以保存为interaction.py,从wetestdemo点击Interaction，然后运行</p>
<div class="highlight highlight-source-batchfile"><pre>python interaction.py</pre></div>
<p>运行后，返回当前可点击的有效节点及他们的位置</p>
<pre><code>Button : GameObject /Canvas/Dialog(Clone)/Sure Instance = 4294957156,Bound : {'y': 733.0, 'x': 660.0}
Button : GameObject /Canvas/Dialog(Clone)/Cancel Instance = 4294957136,Bound : {'y': 733.0, 'x': 1260.0}
</code></pre>
<p>上图返回的就是，Confirm和Canel两个按钮。这两个按钮是有效的可交互的按钮（按下去会有反应的），其他红色圈出来的回退、Click、Press和Close都已经被遮住，在这个位置点击也是无效的。<br>
*<code>engine.get_touchable_elements()</code>*是一个相对耗时的接口，一般腾讯常见的游戏，耗时在80ms以内（在一帧内处理）。返回的是一个元组列表，元组中包含可交互的有效节点和位置（一个x,y的字典），所以无需再请求节点位置，可以直接点击。</p>
<p><a name="4.6"></a></p>
<h2>4.6 获取文字内容</h2>
<p>可以获取到游戏中的文字内容。NGUI能够获取到UILable、UIInput、GUIText组件上的文字内容，如果GameObject上不包含以上组件，将抛出异常。UGUI能够获取Text、GUIText组件上的文字信息。示例在interaction.py中，wetest_demo.apk需要在interaction界面。</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_get_element_txt</span>():
    e<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Click/Text<span class="pl-pds">"</span></span>)
    text<span class="pl-k">=</span>engine.get_element_text(e)
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Text = <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(text))</pre></div>
<p>上面的代码在sample/interaction.py中，运行该函数可以获取文字内容"Click"</p>
<p><a name="4.7"></a></p>
<h2>4.7 获取图片名称</h2>
<p>可以获取到游戏中的GameObject上面对应的图片名称。NGUI取UITexture、UISprite、SpriteRenderer组件上的图片名称，如果GameObject上不包含以上组件，将抛出异常。UGUI能够获取Image、RawImage、SpriteRenderer组件上的图片名称。示例在interaction.py中，wetest_demo.apk需要在interaction界面。</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_get_element_image</span>():
    e <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Back<span class="pl-pds">"</span></span>)
    image <span class="pl-k">=</span> engine.get_element_image(e)
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Image = <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(image))</pre></div>
<p>上面的代码在sample/interaction.py中，运行该函数可以获取图片名称"back"</p>
<p><a name="5"></a></p>
<h1>5 Mobile设备</h1>
<p>*engine.get_device()*类device提供与手机相关信息的API，也提供简单的操作。示例：sample/devices_tester.py</p>
<p><a name="5.1"></a></p>
<h2>5.1 屏幕尺寸与转向</h2>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_get_display_size</span>():
    display_size<span class="pl-k">=</span>device.get_display_size()
    logger.debug(display_size)

    rotation<span class="pl-k">=</span>device.get_rotation()
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Rotation : <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(rotation))

test_get_display_size()
</pre></div>
<p>获取屏幕尺寸，DisplaySize类包括width、height单位为px。</p>
<p><a href="image/device_screen.png" target="_blank"><img src="image/device_screen.png" alt="Drawing" width="600px" style="max-width:100%;"></a></p>
<p><a name="5.2"></a></p>
<h2>5.2 顶层Package与Activity</h2>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_get_top_package_activity</span>():
    top_activity<span class="pl-k">=</span>device.get_top_package_activity()
    logger.debug(top_activity)

test_get_top_package_activity()
</pre></div>
<p>上面的代码可以保存为devices_tester.py,再任意界面启动</p>
<div class="highlight highlight-source-batchfile"><pre>python devices_tester.py</pre></div>
<p>*device.get_top_package_activity()*获取手机当前界面的TopActivity对象，包含顶层app的包名和Activity名称。</p>
<pre><code>package name = com.tencent.wetest.demo,activity = com.unity3d.player.UnityPlayerActivity
</code></pre>
<p><a name="5.3"></a></p>
<h2>5.3 回退键</h2>
<p>GAutomator本身不提供对标准Android控件的支持，所以当界面上出现标准控件时将无法进行操作。因此，提供了回退（Back）操作，返回到游戏Activity。</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_back</span>():
    device.back()
test_back()</pre></div>
<p>上面的代码可以保存为devices_tester.py,再任意界面启动</p>
<div class="highlight highlight-source-batchfile"><pre>python devices_tester.py</pre></div>
<p>*device.back()*与按Android的回退键效果一致。</p>
<p><a name="6"></a></p>
<h1>6 云端报告</h1>
<p>*engine.get_reporter()*获取的Reporter类封装了与云端报告相关的内容，本地实现为空，只有在云端运行的时候才会有效果。游戏自动化测试过程中需要保持测试现场，所以在云端运行过程中需要标记测试过程和截图。Reporter主要负责与功能</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> sys, os, time

<span class="pl-c"><span class="pl-c">#</span>sys.path.append(os.path.abspath(os.path.join(os.getcwd(), "..\\")))</span>

<span class="pl-k">import</span> wpyscripts.manager <span class="pl-k">as</span> manager

engine <span class="pl-k">=</span> manager.get_engine()
logger <span class="pl-k">=</span> manager.get_logger()
reporter <span class="pl-k">=</span> manager.get_reporter()


<span class="pl-k">def</span> <span class="pl-en">screen_shot_click</span>(<span class="pl-smi">element</span>):
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>screen_shot_click<span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> element <span class="pl-k">is</span> <span class="pl-c1">None</span>:
        <span class="pl-k">return</span>
    bound <span class="pl-k">=</span> engine.get_element_bound(element)
    logger.debug(bound)
    pos_x <span class="pl-k">=</span> bound.x <span class="pl-k">+</span> bound.width <span class="pl-k">/</span> <span class="pl-c1">2</span>
    pos_y <span class="pl-k">=</span> bound.y <span class="pl-k">+</span> bound.height <span class="pl-k">/</span> <span class="pl-c1">2</span>
    reporter.capture_and_mark(pos_x, pos_y, <span class="pl-v">locator_name</span> <span class="pl-k">=</span> element.object_name)
    engine.click_position(pos_x, pos_y)


<span class="pl-k">def</span> <span class="pl-en">enter_find_elmeents</span>():
    find_elements_button <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/FindElements<span class="pl-pds">"</span></span>)
    logger.debug(find_elements_button)
    screen_shot_click(find_elements_button)
    time.sleep(<span class="pl-c1">1</span>)

<span class="pl-k">def</span> <span class="pl-en">back_main</span>():
    find_elements_button <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/Back<span class="pl-pds">"</span></span>)
    logger.debug(find_elements_button)
    screen_shot_click(find_elements_button)
    time.sleep(<span class="pl-c1">1</span>)

<span class="pl-k">def</span> <span class="pl-en">test_capture_and_mark</span>():
    elements <span class="pl-k">=</span> engine.find_elements_path(<span class="pl-s"><span class="pl-pds">"</span>/Canvas/Panel/VerticalPanel/Item(Clone)<span class="pl-pds">"</span></span>)
    <span class="pl-k">for</span> element <span class="pl-k">in</span> elements:
        screen_shot_click(element)
        time.sleep(<span class="pl-c1">2</span>)

<span class="pl-k">def</span> <span class="pl-en">test_reporter</span>():
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>test_reporter<span class="pl-pds">"</span></span>)
    enter_find_elmeents()
    time.sleep(<span class="pl-c1">2</span>)
    reporter.add_start_scene_tag(<span class="pl-s"><span class="pl-pds">"</span>Find_Scene<span class="pl-pds">"</span></span>)
    test_capture_and_mark()
    reporter.add_end_scene_tag(<span class="pl-s"><span class="pl-pds">"</span>Find_Scene<span class="pl-pds">"</span></span>)
    time.sleep(<span class="pl-c1">2</span>)
    back_main()
	reporter.screenshot()
</pre></div>
<p>runner.py里面，调用test_reporter()。上传到平台后的结果的运行结果（同事在几百台手机上运行）</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> traceback

<span class="pl-k">try</span>:
    <span class="pl-k">from</span> sample.reporter_tester <span class="pl-k">import</span> <span class="pl-k">*</span>
<span class="pl-k">except</span> <span class="pl-c1">Exception</span>,e:
    traceback.print_exc()

<span class="pl-k">def</span> <span class="pl-en">run</span>():
    <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">        业务逻辑的起点</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
    <span class="pl-k">try</span>:
        test_reporter()
    <span class="pl-k">except</span> <span class="pl-c1">Exception</span>,e:
        traceback.print_exc()
        stack<span class="pl-k">=</span>traceback.format_exc()
        logger.debug(stack)</pre></div>
<p><a href="image/reporter_screen.png" target="_blank"><img src="image/reporter_screen.png" alt="Drawing" width="600px" style="max-width:100%;"></a></p>
<p><a href="image/reporter_perform.png" target="_blank"><img src="image/reporter_perform.png" alt="Drawing" width="600px" style="max-width:100%;"></a></p>
<p><a name="6.1"></a></p>
<h2>6.1 截图与操作过程标记</h2>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">screen_shot_click</span>(<span class="pl-smi">element</span>):
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>screen_shot_click<span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> element <span class="pl-k">is</span> <span class="pl-c1">None</span>:
        <span class="pl-k">return</span>
    bound <span class="pl-k">=</span> engine.get_element_bound(element)
    logger.debug(bound)
    pos_x <span class="pl-k">=</span> bound.x <span class="pl-k">+</span> bound.width <span class="pl-k">/</span> <span class="pl-c1">2</span>
    pos_y <span class="pl-k">=</span> bound.y <span class="pl-k">+</span> bound.height <span class="pl-k">/</span> <span class="pl-c1">2</span>
    reporter.capture_and_mark(pos_x, pos_y, <span class="pl-v">locator_name</span> <span class="pl-k">=</span> element.object_name)
    engine.click_position(pos_x, pos_y)</pre></div>
<p>*reporter.capture_and_mark(pos_x, pos_y, locator_name = element.object_name)*将会截取当前手机屏幕，并在pos_x,pos_y位置标记一个红点。</p>
<p><a href="image/screen_mark.jpg" target="_blank"><img src="image/screen_mark.jpg" alt="Drawing" width="400px" style="max-width:100%;"></a></p>
<p><a name="6.2"></a></p>
<h2>6.2 截图</h2>
<p>*reporter.screenshot()*在云端会截图在报告里面体现，在本地运行时会截图并放在运行目录下的screenshot目录下面。</p>
<p><a name="6.3"></a></p>
<h2>6.3 打标签</h2>
<div class="highlight highlight-source-python"><pre>reporter.add_start_scene_tag(<span class="pl-s"><span class="pl-pds">"</span>Find_Scene<span class="pl-pds">"</span></span>)
reporter.add_end_scene_tag(<span class="pl-s"><span class="pl-pds">"</span>Find_Scene<span class="pl-pds">"</span></span>)</pre></div>
<p>*reporter.add_start_scene_tag("")和reporter.add_end_scene_tag("")*一定是成对出现的，先start然后end，里面的标签内容需要一样。</p>
<p><a href="image/tag.png" target="_blank"><img src="image/tag.png" alt="Drawing" width="600px" style="max-width:100%;"></a></p>
<p><strong>注：配合engine.get_scene()效果更佳</strong></p>
<h2>6.4 报告错误</h2>
<p>GAutomator并不是使用常见的，unittest作为测试的底层框架，因此并无断言，无法做功能测试。report_error接口，可用于错误报告，并且在运行目录下生成一份_wetest_testcase_result.txt用户记录报告的内容。该文件的报告格式与unittest的测试报告格式一致，因此在云端测试时可现实具体的信息。</p>
<div class="highlight highlight-source-python"><pre>report.report_error(<span class="pl-s"><span class="pl-pds">"</span>testcase<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>content<span class="pl-pds">"</span></span>)
report.report_error(<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">"</span>report_test<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">"</span>Report test error 中文<span class="pl-pds">"</span></span>)</pre></div>
<p>*reporter.report_error(name,message)*接口调用的过程中，会在日志中输出。脚本运行结束时，runner.run中，会调用_report_total(),将所有的判断结果输出到_wetest_testcase_result.txt中。除了输出message和test_case_name之外GAutomator还会加上调用堆栈。name的名称尽可能不重复。name与message传入的编码方式需要一致，如果存在中文的情况下必须要使用UTF-8编码格式。</p>
<p><a name="7"></a></p>
<h1>7 定制功能</h1>
<p>GAutomatorView不可能集成所有的功能，部分功能也不方便通过简单的触屏操作完成，或者通过触屏操作完成的复杂度极高。定制功能，可以向WeTest SDK注册委托，通过python脚本来触发委托的执行，并将结果返回给python脚本。<br>
该功能需要游戏开发者和游戏测试者协同完成<br>
1、游戏中注册，自定义函数<br>
2、自动化脚本，调用自定义函数<br>
<a name="7.1"></a></p>
<h2>7.1 Unity游戏端注册委托</h2>
<p>Unity游戏开发者需要，注册对应的函数供脚本调用，如完成英雄位移等</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> <span class="pl-en">UnityEngine</span>;
<span class="pl-k">using</span> <span class="pl-en">System.Collections</span>;
<span class="pl-k">using</span> <span class="pl-en">WeTest.U3DAutomation</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">CustomTester</span> : <span class="pl-en">MonoBehaviour</span> {
	<span class="pl-k">void</span> <span class="pl-en">Start</span> () {

        Debug.Log(<span class="pl-s"><span class="pl-pds">"</span>Register test<span class="pl-pds">"</span></span>);
        WeTest.U3DAutomation.CustomHandler.RegisterCallBack(<span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span>, testReq);
	}

    <span class="pl-k">string</span> <span class="pl-en">testReq</span>(<span class="pl-k">string</span> <span class="pl-smi">args</span>)
    {
        Debug.Log(<span class="pl-s"><span class="pl-pds">"</span>Args = <span class="pl-pds">"</span></span> + args);
        <span class="pl-k">string</span> <span class="pl-en">result</span> = args + <span class="pl-s"><span class="pl-pds">"</span> Response<span class="pl-pds">"</span></span>;
        <span class="pl-k">return</span> result;
    }

    <span class="pl-k">void</span> <span class="pl-en">OnDestroy</span>()
    {
        Debug.Log(<span class="pl-s"><span class="pl-pds">"</span>UnRegister test<span class="pl-pds">"</span></span>);
        CustomHandler.UnRegisterCallBack(<span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span>);
    }
}
</pre></div>
<p><em>WeTest.U3DAutomation.CustomHandler.RegisterCallBack("test", testReq)</em>:主要一个注册的函数的名称和一个函数。注册了这个函数之后，脚本执行时如果发送执行test，SDK就会调用testReq（string arg）这个函数，并把脚本发送过来的内容作为string参数传入。函数返回结果会返回给脚本端。<br>
<em>CustomHandler.UnRegisterCallBack("test")</em>:将函数从注册表中移除。</p>
<p><a name="7.2"></a></p>
<h2>7.2 脚本调用</h2>
<p>wpyscripts能够直接调用游戏中的注册函数，并获取返回值。<strong>示例：sample/self_define_fun.py</strong><br>
<a name="7.2.1"></a></p>
<h3>7.2.1 获取可执行委托</h3>
<p>*engine.get_registered_handlers()*可以获取当前可以用的注册名单</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_get_registered_handlers</span>():
    result <span class="pl-k">=</span> engine.get_registered_handlers()

    <span class="pl-k">for</span> name <span class="pl-k">in</span> result:
        logger.debug(name)

test_get_registered_handlers()</pre></div>
<p>确保wetest_demo.apk在拉起来的界面</p>
<div class="highlight highlight-source-batchfile"><pre>python self_define_fun.py</pre></div>
<p>运行后，可以获取当前，注册的函数为"test"</p>
<p><a name="7.2.2"></a></p>
<h3>7.2.2 执行委托</h3>
<p><em>engine.call_registered_handler("test", "python call test")</em>:可以调用SDK中注册的委托</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_call_registered_handler</span>():
    result <span class="pl-k">=</span> engine.call_registered_handler(<span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>python call test<span class="pl-pds">"</span></span>)
    logger.debug(result)

test_call_registered_handler()
</pre></div>
<p>确保wetest_demo.apk在拉起来的界面</p>
<div class="highlight highlight-source-batchfile"><pre>python self_define_fun.py</pre></div>
<p>运行"test"关键词对应的注册的委托，传入参数为"python call test"。获取委托执行后的返回值"python call test Response"</p>
<p><a name="7.2.3"></a></p>
<h3>7.2.3 获取组件上的方法</h3>
<p>可以获取到游戏中的GameObject上某个Component上的public方法信息，包括方法名称，方法需要的参数和返回的类型。在wetest_demo.apk中，Sample按钮上挂载了ReflectionTest组件，可以使用下面代码返回该组件中的方法。</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_get_component_methods</span>(<span class="pl-smi"><span class="pl-smi">self</span></span>):
    element <span class="pl-k">=</span> <span class="pl-c1">self</span>.engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Sample<span class="pl-pds">"</span></span>)
    methods <span class="pl-k">=</span> <span class="pl-c1">self</span>.engine.get_component_methods(element, <span class="pl-s"><span class="pl-pds">"</span>ReflectionTest<span class="pl-pds">"</span></span>)
    logger.debug(methods)</pre></div>
<p>上面的代码在sample/interaction.py中，运行该函数可以获得全部的public方法。</p>
<p><a name="7.2.4"></a></p>
<h3>7.2.4 调用组件上的方法</h3>
<p>通过反射可以调用GameObject某个组件上的public方法，并获得返回值。调用时需要传入组件名称、方法名称和参数列表。wetest_demo.apk中调用Sample按钮ReflectionTest组件上的TestReflection方法（需要两个参数int,string,返回int值），调用代码如下：</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_call_component_method</span>(<span class="pl-smi"><span class="pl-smi">self</span></span>):
    element <span class="pl-k">=</span> <span class="pl-c1">self</span>.engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Sample<span class="pl-pds">"</span></span>)
    params <span class="pl-k">=</span> []
    params.append(<span class="pl-c1">5</span>)
    params.append(<span class="pl-s"><span class="pl-pds">"</span>Hello World<span class="pl-pds">"</span></span>)
    result <span class="pl-k">=</span> <span class="pl-c1">self</span>.engine.call_component_method(element, <span class="pl-s"><span class="pl-pds">"</span>ReflectionTest<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>TestReflection<span class="pl-pds">"</span></span>, params)
    logger.debug(result)</pre></div>
<p>上面的代码在sample/interaction.py中，将调用游戏中的TestReflection方法，并返回105（方法的返回值）。</p>
<p><a name="7.3"></a></p>
<h2>7.3 反射获取游戏中属性值</h2>
<p>在使用自动化测试过程中，定制一些高级功能时，现有的接口获取的数据可能无法满足需求。如，希望根据英雄血量来定制策略。因此，GAutomator提供了一个高级接口，通过反射的方式获取游戏中组件里面的属性值。*get_component_field(element,component,attribute)*接口可以获取GameObject上组件对应的属性值</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_get_component_field</span>(<span class="pl-smi"><span class="pl-smi">self</span></span>):
        elements <span class="pl-k">=</span> <span class="pl-c1">self</span>.engine.find_elements_path(<span class="pl-s"><span class="pl-pds">"</span>Sample/Text<span class="pl-pds">"</span></span>)
        <span class="pl-c1">self</span>._start()
        res <span class="pl-k">=</span> <span class="pl-c1">self</span>.engine.get_component_field(elements[<span class="pl-c1">0</span>], <span class="pl-s"><span class="pl-pds">"</span>Text<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>text<span class="pl-pds">"</span></span>)
        <span class="pl-c1">self</span>._end(<span class="pl-s"><span class="pl-pds">"</span>get_component_field<span class="pl-pds">"</span></span>)
        <span class="pl-c1">self</span>.assertEqual(res, <span class="pl-s"><span class="pl-pds">"</span>Sample<span class="pl-pds">"</span></span>)

        e <span class="pl-k">=</span> <span class="pl-c1">self</span>.engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Panel<span class="pl-pds">"</span></span>)
        res <span class="pl-k">=</span> <span class="pl-c1">self</span>.engine.get_component_field(e, <span class="pl-s"><span class="pl-pds">"</span>MainControl<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>bollon<span class="pl-pds">"</span></span>)
        <span class="pl-c1">self</span>.assertEqual(res, <span class="pl-s"><span class="pl-pds">"</span>Bollon (UnityEngine.RectTransform)<span class="pl-pds">"</span></span>)</pre></div>
<p>确保wetest_demo.apk在拉起来的界面，运行结果可以看到获取了Sample/Text GameObject上面组件Text中对应text属性的值为Sample。GAutomator获取到组件属性后，会直接调用toString()转换为string字符串。如果属性本身也是Object，toString()之后的值可能意义并不会特别大如（Bollon (UnityEngine.RectTransform)）。现在暂时未提供级联的操作，无法获取对象Bollon上的属性值。</p>
<p><a name="7.4"></a></p>
<h2>7.4 设置最佳渲染Camera</h2>
<p>Unity里面一个物体可能会被多个Camera渲染，如有一个主摄像机还会有光晕渲染等摄像机。WeTest SDK中会寻找一个最佳的Camera，但是有的时候可能找到的Camera并不准确。具体表现为，渲染的物体大小及位置不准确，可能是远大于实际的长宽。<br>
GAutomatorView查看物体，发现长宽高不对时。可以使用set_camera设置其他相机，然后再用GAutomatorView尝试看是否恢复正常，恢复正常了则该GameObject为最适合的摄像机。engine中<em>et_camera(gameobject_name)</em>：设置Camera所在的gameobject名称。</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-en">engine.set_camera</span>("CharModeCamera")
</pre></div>
<p>设置Camera后，如果物体渲染的Camera中包含设置的Camera，则会直接采用设置的Camera。<a href="https://docs.unity3d.com/ScriptReference/Camera.html" title="UnityCamer资料" rel="nofollow">UnityCamera资料</a></p>
<p><a name="7.5"></a></p>
<h2>7.5 调用第三方C#脚本</h2>
<p>Unity手游自动化过程中，纯UI的自动化面临越来越大的瓶颈，如人物的自动寻路、人物的战斗属性获取等通过UI的方式获取困难。因此，GAutomator一个功能，允许将自己的C#脚本注入到游戏中。能够以C#脚本的方式，调用游戏内的接口，获取游戏内的数据。<br>
GAutomator python端提供了接口engine.game_script_init(),会将gametestlib.dll推送到/data/local/tmp，然后调用gametestlib.dll下的GameTest.Test.init方法，该方法无参数与无返回值。因此，通常会在改接口中调用WeTest.U3DAutomation.CustomHandler.RegisterCallBack，将需要调用的函数注册上去，利用engine.call_registered_handler机制完成python调用游戏中C#脚本</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_game_script_init</span>(<span class="pl-smi"><span class="pl-smi">self</span></span>):
    file_path <span class="pl-k">=</span> os.path.split(os.path.realpath(<span class="pl-c1">__file__</span>))[<span class="pl-c1">0</span>]
    path<span class="pl-k">=</span>os.path.join(file_path,<span class="pl-s"><span class="pl-pds">"</span>gametestlib.dll<span class="pl-pds">"</span></span>)
    result<span class="pl-k">=</span><span class="pl-c1">self</span>.engine.game_script_init(path)
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>init result : <span class="pl-pds">"</span></span>.format(result))

    result<span class="pl-k">=</span><span class="pl-c1">self</span>.engine.get_registered_handlers()
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>registered functions : <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(result))

    result<span class="pl-k">=</span><span class="pl-c1">self</span>.engine.call_registered_handler(<span class="pl-s"><span class="pl-pds">"</span>showColider<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)</pre></div>
<p>启动wetest_demo，点击Joystick按钮，进入到摇杆页面。然后运行代码，所有的柱子会变成粉红色。执行了gametestlib.dll中的，showColider方法。<br>
<a href="https://share.weiyun.com/b27da45dc1013db82b09cd4a31625056" rel="nofollow">gametestlib source</a>编写的时候，注意事项：<br>
1、vs编写，工程名称任意。Assembly name为gametestlib<br>
2、非IL2CPP编译的apk，用压缩软件打开，在assets\bin\Data\Managed下的dll为游戏脚本。可以作为gametestlib编写的依赖。<br>
3、初始化模板固定</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-k">namespace</span> <span class="pl-en">GameTest</span> //固定 namespace为GameTest
{
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Test</span> //初始化类名固定
    {
        <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">init</span>() <span class="pl-c">//初始化函数，GA只支持调用该函数，在该函数中注册委托</span>
        {
            WeTest.U3DAutomation.CustomHandler.RegisterCallBack(<span class="pl-s"><span class="pl-pds">"</span>TEST<span class="pl-pds">"</span></span>, test);
            WeTest.U3DAutomation.CustomHandler.RegisterCallBack(<span class="pl-s"><span class="pl-pds">"</span>RecordPath<span class="pl-pds">"</span></span>, record);
            WeTest.U3DAutomation.CustomHandler.RegisterCallBack(<span class="pl-s"><span class="pl-pds">"</span>showColider<span class="pl-pds">"</span></span>, addBoxColider);
        }
    }
}</pre></div>
<p><a name="7.6"></a></p>
<h2>7.6 C#脚本调用Python函数</h2>
<p>SDK 1.5.0版本提供接口，可以调用python注册的函数。该功能类似于远程RPC调用，C#脚本调用python端的实现，可传递string参数与获取返回值。<br>
SDK接口<br>
<em>WeTest.U3DAutomation.CustomHandler.InvokeClientMethod(string name, string params,PcCallBack callback)</em><br>
异步调用，name为python端注册的函数名称，params为传递的参数（以json方式传输），callback为python端执行完毕后的回调函数</p>
<p><em>WeTest.U3DAutomation.CustomHandler.InvokeClientMethodReturnValue(string name, string params,int timeout)</em><br>
同步调用，name为python端注册的函数名称，params为传递的参数（以json方式传输），timeout为超时时长单位为毫秒。返回值string,为远程python注册函数的返回值。</p>
<p><em>WeTest.U3DAutomation.CustomHandler.InvokeClientMethod(string name, string value)</em><br>
异步调用（无返回值）,name为python端注册的函数名称，params为传递的参数（以json方式传输）。调用后立刻返回。</p>
<p>wetest_demo首页的CallPc注册了3个点击处理函数,c#代码</p>
<div class="highlight highlight-source-cs"><pre>    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">printResult</span>(<span class="pl-k">int</span> <span class="pl-smi">status</span>, <span class="pl-k">string</span> <span class="pl-smi">message</span>)
    {
        Debug.Log(<span class="pl-s"><span class="pl-pds">"</span>call back result = <span class="pl-pds">"</span></span> + message + <span class="pl-s"><span class="pl-pds">"</span> status = <span class="pl-pds">"</span></span> + status);
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">CallPythonClient</span>(<span class="pl-en">GameObject</span> <span class="pl-smi">obj</span>)
    {

        <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">         * call python register function "_print_fun"</span>
<span class="pl-c">         * </span>
<span class="pl-c">         * def _print_fun(v):</span>
<span class="pl-c">         *   print "game call"</span>
<span class="pl-c">         *   print "value = "+v</span>
<span class="pl-c">         *   return "_print_fun call return value"</span>
<span class="pl-c">         * </span>
<span class="pl-c">         * engine.register_game_callback("test", _print_fun)</span>
<span class="pl-c">         * </span>
<span class="pl-c">         <span class="pl-c">*/</span></span>
        WeTest.U3DAutomation.CustomHandler.InvokeClientMethod(<span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>call python client callback<span class="pl-pds">"</span></span>, printResult);
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">CallPythonClientReturnValue</span>(<span class="pl-en">GameObject</span> <span class="pl-smi">obj</span>)
    {
        <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">         * call python register function "_print_fun_returnvalue"</span>
<span class="pl-c">         * </span>
<span class="pl-c">         * def _print_fun_returnvalue(v):</span>
<span class="pl-c">         *   print "game call return value"</span>
<span class="pl-c">         *   print "value = "+v</span>
<span class="pl-c">         *   return "_print_fun_returnvalue call return value"</span>
<span class="pl-c">         * </span>
<span class="pl-c">         * engine.register_game_callback("testReturn", _print_fun_returnvalue)</span>
<span class="pl-c">         * </span>
<span class="pl-c">        <span class="pl-c">*/</span></span>
        <span class="pl-k">string</span> <span class="pl-en">result</span> = WeTest.U3DAutomation.CustomHandler.InvokeClientMethodReturnValue(<span class="pl-s"><span class="pl-pds">"</span>testReturn<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>call python client return value<span class="pl-pds">"</span></span>, <span class="pl-c1">1000</span>);
        Debug.Log(<span class="pl-s"><span class="pl-pds">"</span>CallPythonClientReturnValue return value = <span class="pl-pds">"</span></span> + result);
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">CallPythonClientReturnNone</span>(<span class="pl-en">GameObject</span> <span class="pl-smi">obj</span>)
    {
        <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">         * call python register function "_print_fun_returnvalue",ignore the return value</span>
<span class="pl-c">         * </span>
<span class="pl-c">         * def _print_fun_returnvalue(v):</span>
<span class="pl-c">         *   print "game call return value"</span>
<span class="pl-c">         *   print "value = "+v</span>
<span class="pl-c">         *   return "_print_fun_returnvalue call return value"</span>
<span class="pl-c">         * </span>
<span class="pl-c">         * engine.register_game_callback("testReturn", _print_fun_returnvalue)</span>
<span class="pl-c">         * </span>
<span class="pl-c">        <span class="pl-c">*/</span></span>
        WeTest.U3DAutomation.CustomHandler.InvokeClientMethod(<span class="pl-s"><span class="pl-pds">"</span>testReturn<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>call python client not return value<span class="pl-pds">"</span></span>);
    }</pre></div>
<p>python端注册处理函数</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">_print_fun</span>(<span class="pl-smi">v</span>):
    <span class="pl-c1">print</span> <span class="pl-s"><span class="pl-pds">"</span>game call<span class="pl-pds">"</span></span>
    <span class="pl-c1">print</span> <span class="pl-s"><span class="pl-pds">"</span>value = <span class="pl-pds">"</span></span><span class="pl-k">+</span>v
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>_print_fun call return value<span class="pl-pds">"</span></span>

<span class="pl-k">def</span> <span class="pl-en">_print_fun_returnvalue</span>(<span class="pl-smi">v</span>):
    <span class="pl-c1">print</span> <span class="pl-s"><span class="pl-pds">"</span>game call return value<span class="pl-pds">"</span></span>
    <span class="pl-c1">print</span> <span class="pl-s"><span class="pl-pds">"</span>value = <span class="pl-pds">"</span></span><span class="pl-k">+</span>v
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>_print_fun_returnvalue call return value<span class="pl-pds">"</span></span>

result <span class="pl-k">=</span> engine.register_game_callback(<span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span>, _print_fun)
logger.debug(<span class="pl-s"><span class="pl-pds">"</span>register game callback <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(result))
result <span class="pl-k">=</span> engine.register_game_callback(<span class="pl-s"><span class="pl-pds">"</span>testReturn<span class="pl-pds">"</span></span>, _print_fun_returnvalue)
logger.debug(<span class="pl-s"><span class="pl-pds">"</span>register game callback <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(result))

callPcButton<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>CallPC<span class="pl-pds">"</span></span>)
engine.click(callPcButton)</pre></div>
<p><a name="8"></a></p>
<h1>8 实战用例</h1>
<p>举例最常见的，较难处理的引用场景scripts/testcase/tools.py封装了，场景的使用场景</p>
<p><a name="8.1"></a></p>
<h2>8.1 摇杆</h2>
<p>MOBA游戏越来越流行，摇杆类游戏区别需要滑动和按压连续操作。Wpyscripts提供了专门针对摇杆类动作的封装*engine.swipe_and_press(start_x, start_y, end_x, end_y, steps, duration, step_sleep=5)*能够实现，对大部分摇杆的操作。实例位置sample/joystick_tester.py</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">convert_pos</span>(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>):
    display_size <span class="pl-k">=</span> device.get_display_size()
    <span class="pl-k">return</span> x <span class="pl-k">*</span> display_size.width, y <span class="pl-k">*</span> display_size.height

<span class="pl-k">def</span> <span class="pl-en">test_swipe_and_press</span>():
    time.sleep(<span class="pl-c1">2</span>)
    start_time<span class="pl-k">=</span>datetime.datetime.now()
    start_x,start_y<span class="pl-k">=</span>convert_pos(<span class="pl-c1">0.1197916</span>,<span class="pl-c1">0.796296</span>)
    end_x,end_y<span class="pl-k">=</span>convert_pos(<span class="pl-c1">0.1197916</span>,<span class="pl-c1">0.69444</span>)
    engine.swipe_and_press(start_x,start_y,end_x,end_y,<span class="pl-c1">100</span>,<span class="pl-c1">10000</span>)

    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Use time : <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(datetime.datetime.now()<span class="pl-k">-</span>start_time))
    time.sleep(<span class="pl-c1">3</span>)

test_swipe_and_press()</pre></div>
<p>上面的代码可以保存为joystick_tester.py,点击JoyStick按钮，进入摇杆操作界面</p>
<div class="highlight highlight-source-batchfile"><pre>python joystick_tester.py</pre></div>
<ul>
<li><code>start_x,start_y</code>,表示滑动的起始位置</li>
<li><code>end_x,end_y</code>,表示滑动的结束位置</li>
<li><code>steps</code>，表示滑动中间经过的步骤数，每一步的时间约为5ms。滑动的步骤数控制着滑动的速度和平滑度</li>
<li><code>step_sleep</code>:每个步骤的间隔时长，单位毫秒</li>
<li><code>duration</code>，结束位置按压时间，单位是毫秒ms</li>
</ul>
<p><a name="8.2"></a></p>
<h2>8.2 记录操作流程</h2>
<p>自动化测试记录操作流程，有利于出现bug时定位和复现。所以原则上，应该记录每一步操作。tools.py里面封装了一个接口，能够在截图上标记点击的位置，然后执行点击操作，点击完成等待相应的时间。</p>
<ul>
<li>screen_shot_click(element,sleeptime)接口,传入需要点击的节点和点击后等待时间。</li>
</ul>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">screen_shot_click</span>(<span class="pl-smi">element</span>, <span class="pl-smi">sleeptime</span><span class="pl-k">=</span><span class="pl-c1">2</span>):
    <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">        点击，并标记红点。</span>
<span class="pl-s">    :param element: 需要点击的element</span>
<span class="pl-s">    :param sleeptime:</span>
<span class="pl-s">    :return:</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
    <span class="pl-k">if</span> element <span class="pl-k">is</span> <span class="pl-c1">None</span>:
        <span class="pl-k">return</span>
    <span class="pl-k">try</span>:
        bound <span class="pl-k">=</span> engine.get_element_bound(element)
    <span class="pl-k">except</span> WeTestRuntimeError, e:
        bound <span class="pl-k">=</span> <span class="pl-c1">None</span>
    <span class="pl-k">if</span> <span class="pl-k">not</span> bound:
        <span class="pl-k">return</span>
    logger.debug(bound)
    pos_x <span class="pl-k">=</span> bound.x <span class="pl-k">+</span> bound.width <span class="pl-k">/</span> <span class="pl-c1">2</span>
    pos_y <span class="pl-k">=</span> bound.y <span class="pl-k">+</span> bound.height <span class="pl-k">/</span> <span class="pl-c1">2</span>
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>screen_shot_click_pos x = <span class="pl-c1">{0}</span>,y = <span class="pl-c1">{1}</span>,name = <span class="pl-c1">{2}</span><span class="pl-pds">"</span></span>.format(pos_x, pos_y, element.object_name))
    report.capture_and_mark(pos_x, pos_y, <span class="pl-v">locator_name</span><span class="pl-k">=</span>element.object_name)
    engine.click_position(pos_x, pos_y)

    time.sleep(sleeptime)</pre></div>
<p>传入的element为空或者element的位置找不到，则自动跳过。</p>
<div class="highlight highlight-source-python"><pre>qq_button <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>/BootObj/CUIManager/Form_Login/LoginContainer/pnlMobileLogin/btnGroup/btnQQ<span class="pl-pds">"</span></span>)
screen_shot_click(qq_button, <span class="pl-c1">6</span>)</pre></div>
<p><a name="8.3"></a></p>
<h2>8.3 QQ或微信登录</h2>
<p>QQ或者微信登录，设计到Activity的切换和Android标准控件的操作,操作过程复杂，但是相对较为固定。在云端运行时，每次拉起游戏之前，都会清理数据，所以每次都需要重新登录。每次登录的过程如下所示：</p>
<p><a href="image/login_step.png" target="_blank"><img src="image/login_step.png" alt="Drawing" width="600px" style="max-width:100%;"></a></p>
对应的处理代码如下所示：
```python
def login():
    # 步骤1，等待到达登录界面
    wait_for_scene("SceneName")
<pre><code># 选择QQ登陆
qq_button = find_elment_wait("/BootObj/Panel/btnQQ")
screen_shot_click(qq_button, 6)

#步骤2 ，等待进入QQ登录界面，packagename为com.tencent.mobileqq，如果是微信登录界面package为com.tencent.mm
wait_for_package("com.tencent.mobileqq")
device.login_qq_wechat_wait(120)
time.sleep(10)

#步骤3，等待QQ登录界面退出，切换到游戏界面
select_btn = find_elment_wait("/BootObj/Panle/selectBtn")
</code></pre>
<pre><code>1. 步骤1：等待进入到登录选择scene，如何获取scene名称，请看[1.4 GAutomatorView](#1.4)。wait_for_scene("SceneName")，会一直查询，直到进入名称为"SceneName"的场景。进入到"SceneName"的场景后，查询QQ登录按钮直到出现(find_elment_wait)，并点击QQ登录按钮。
2. 步骤2：从游戏的Activity切换到QQ或者微信的登录界面需要一定的时间。`wait_for_package("com.tencent.mobileqq")`检查顶层包名，直到QQ的顶层包名(微信包名为com.tencent.mm)。`device.login_qq_wechat_wait(120)`会根据当前的顶层包名，自动选择QQ或者微信登录，当顶层包名不再是"com.tencent.mm"或"com.tencent.mobileqq"时推出。
**注：账号由云端自动分配。本地调试时请修改wpyscripts/wetest/device.py下面`native_deivce.__init__(self)`中的账号密码**
3. 步骤3：等待进入游戏界面，直到出现某个element为止。

&lt;a name="8.4"&gt;&lt;/a&gt;

## 8.4 战斗场景随机操作
进入战斗场景后，我们通常可以在里面进行随机操作，直到比赛结束。scripts/testcase/tools.py里面封装了一个random_click(fun=None, forbid_elements=(),max_num=1000,sleep = 2)
```python
def random_click(fun=None, forbid_elements=(),max_num=1000,sleep = 2):
    """
        随机点击界面上的可操作控件。
    :param fun: 如果fun调用返回True，则随机点击结束
    :param forbid_elements: 禁止点击的组件列表(如退出键)
    :param max_num:最大点击次数
    :param sleep:每次点击后的睡眠时间
    :return:
    """
    logger.debug("Random click")
    elements = engine.get_touchable_elements()
    for i in range(max_num):
        if elements is None or len(elements) &lt;= 0:
            time.sleep(1)
            elements=engine.get_touchable_elements()
            continue
        if fun and fun(elements):
            logger.info("Find need elements")
            return
        elements = filter(lambda e: e[0].object_name not in forbid_elements,elements)
        e,pos = find_less_click_element(elements)
        if pos is None:
            continue
        screen_shot_click_pos(pos["x"], pos["y"], e.object_name)
        time.sleep(sleep)
        elements = engine.get_touchable_elements()
</code></pre>
<p><a href="image/fight_random_click.png" target="_blank"><img src="image/fight_random_click.png" alt="Drawing" width="600px" style="max-width:100%;"></a></p>
<p>上面王者荣耀这个游戏，进入游戏战斗场景后，就可以随意操作界面里面的按钮（除了暂停），如技能、英雄切换、攻击。如果，比赛胜利，则会弹出"点击屏幕继续"这个element。</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">get_condition_fun</span>(<span class="pl-k">*</span><span class="pl-smi">name</span>):
    <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">        主要用于random_click，传入一系列的elements，只要可点击的节点里面有符合的就返回</span>
<span class="pl-s"></span>
<span class="pl-s">        应用场景：需要点击某个节点，但是在该界面可能出现弹出框。弹出框不确定的情况下，可以使用</span>
<span class="pl-s">    :param name:</span>
<span class="pl-s">    :return:</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
    <span class="pl-k">def</span> <span class="pl-en">find_need_element</span>(<span class="pl-smi">elements</span>):
        <span class="pl-k">for</span> e,pos <span class="pl-k">in</span> elements:
            <span class="pl-k">if</span> e.object_name <span class="pl-k">in</span> name:
                logger.info(<span class="pl-s"><span class="pl-pds">"</span>Find element name <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(e.object_name))
                <span class="pl-k">return</span> <span class="pl-c1">True</span>
        <span class="pl-k">return</span> <span class="pl-c1">False</span>

    <span class="pl-k">return</span> find_need_element

<span class="pl-c"><span class="pl-c">#</span> 比赛随机点</span>
random_click(get_condition_fun(<span class="pl-s"><span class="pl-pds">"</span>/Root/Panel/ContinueBtn<span class="pl-pds">"</span></span>),
                         (<span class="pl-s"><span class="pl-pds">"</span>/Root/Pause/Button<span class="pl-pds">"</span></span>))</pre></div>
<p>可点击的节点中出现"/Root/Panel/ContinueBtn"则random_click退出。界面中的"/Root/Pause/Button"不需要进行点击。<br>
random_click()会优先点点击次数最少的按钮。</p>
<p><a name="8.5"></a></p>
<h2>8.5 选区操作</h2>
<p>所有账户需要进入指定服务器，需要选区（大部分情况下，区按钮Element名称是一样的）。选区可以巧妙的利用find_elements_path()来点击指定的服务器。</p>
<p><a href="image/select_section.png" target="_blank"><img src="image/select_section.png" alt="Drawing" width="600px" style="max-width:100%;"></a></p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">select_section</span>():
    <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">        选区</span>
<span class="pl-s">    :return:</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
    select_btn <span class="pl-k">=</span> find_elment_wait(<span class="pl-s"><span class="pl-pds">"</span>/Root/pnlStartGame/Panel<span class="pl-pds">"</span></span>)
    screen_shot_click(select_btn, <span class="pl-c1">5</span>)

    servers <span class="pl-k">=</span> engine.find_elements_path(
        <span class="pl-s"><span class="pl-pds">"</span>/Root/Form_Login/ZoneContainer/ScrollRect/Content/*{txt=1区-10区}<span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> <span class="pl-c1">len</span>(servers) <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>:
        screen_shot_click(servers[<span class="pl-c1">0</span>], <span class="pl-c1">3</span>)

    old_server <span class="pl-k">=</span> engine.find_elements_path(
        <span class="pl-s"><span class="pl-pds">"</span>/Root/Form_Login/ZoneContainer/ScrollRect/Content/*{txt=手Q1区 王者独尊}<span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> <span class="pl-c1">len</span>(old_server) <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>:
        screen_shot_click(old_server[<span class="pl-c1">0</span>], <span class="pl-c1">4</span>)

    start_game_button <span class="pl-k">=</span> find_elment_wait(<span class="pl-s"><span class="pl-pds">"</span>/Root/Form_Login/ZoneContainer/ScrollRect/Content/btnStartGame<span class="pl-pds">"</span></span>)
    screen_shot_click(start_game_button, <span class="pl-c1">10</span>)</pre></div>
<p>充分利用engine.find_elements_path()中的txt查找功能，找到指定的服务器。</p>
<p><a name="8.6"></a></p>
<h2>8.6 自动化探索遍历</h2>
<p>用户除了编程实现游戏的各类操作外，还可以直接调用<strong>wpyscripts</strong>框架提供的方法，进行界面的自动化探索遍历测试。示例代码<strong>sample/travel_tester.py</strong></p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_travel</span>():
	<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    :param statfilename: 探索遍历测试完成后生成的统计信息文件名，建议保持"policy.log"不变</span>
<span class="pl-s">    :param forbid_elements: 禁止点击的组件列表(如退出键)</span>
<span class="pl-s">    :param mode: 新老两种模式的选项，建议保持为0不变</span>
<span class="pl-s">    :param max_num: 自动化探索遍历的总点击次数</span>
<span class="pl-s">    :return:</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
    travel.explore(<span class="pl-s"><span class="pl-pds">"</span>policy.log<span class="pl-pds">"</span></span>, [], <span class="pl-v">mode</span><span class="pl-k">=</span><span class="pl-c1">0</span>, <span class="pl-v">max_num</span><span class="pl-k">=</span><span class="pl-c1">30</span>)

test_travel()</pre></div>
<p>运行这个方法，travel.explore函数就会自动遍历。禁止按钮如果没有的话可以不传。<br>
利用这个方法，用户不用编写任何逻辑代码，<strong>wpyscripts</strong>框架就会探索遍历游戏的各个界面，并尽可能的点击每一个界面按钮</p>
<p><a name="8.7"></a></p>
<h2>8.7 异常处理</h2>
<p>对于GAutomator的异常处理是一件非常头痛的事情，在设计框架的过程中也是左右为难，本质原因在于手机的端的不稳定性。不稳定主要包括以下几方面：</p>
<ol>
<li>adb不稳定:windows的adb及其不稳定长期连接过程中不可避免的会出现断开连接的情况。出现断开的情况在腾讯可能有应用宝tadb.exe端口抢占、IOA、QQ浏览器及其他所有手机助手。wetest平台重写了adb，并且运行在linux之上稳定性好很多。adb断开连接，不可恢复，脚本退出。</li>
<li>游戏不稳定:SDK部分与UI相关的内容运行在UI主线程，当游戏暂停时可能会出现timeout的情况。如，QQ登录按钮跳转到登录界面，分享按钮，游戏会退出前台主线程暂停。</li>
<li>UIAutomator不稳定：UIAutomator并不是一个非常稳定的服务，可能会出现操作无效的情况。</li>
</ol>
<p>框架本身，只要是框架处理不了的异常，都会抛给调用者。</p>
<ol>
<li>测试编写的过程中，如果出现操作的内容，可能会让游戏退出前台engine相关接口尽量catch。</li>
<li>对于操作可有可无的，也尽量catch。如点击操作不影响测试流程，如攻击按钮，可以选择catch</li>
</ol>
<p><a name="9"></a></p>
<h1>9 实际使用接口</h1>
<p>GAutomator主要的大三类接口engine,reporter，device属于颗粒度非常细的接口，尽可能的原子化，但是直接使用这部分内容进行开发的话，并不是一件容易的事情。所以，根据在实际项目中使用的经验，我们封装了一些更加方便的、易于使用、不容易出错的接口，供开发人员快速的开发出稳定有效的测试用例。<br>
<a name="9.1"></a></p>
<h2>9.1 screen_shot_click 点击控件截图并记录轨迹</h2>
<p>在使用过程中该接口基本，可以替代GameEngine.click。操作流程为截图-&gt;点击的位置标记红点-&gt;点击-&gt;sleep指定的时间，这个操作过程是比较理想的，也是一个最基本的操作。<br>
wetest平台截图的速度非常快，对性能影响也极低，可以对每一个操作步骤均进行截图。<br>
<em><code>screen_shot_click(element, sleeptime=2, exception=False)</code></em><br>
element:可以为Element实例，也可以为需要点击的name<br>
sleeptime:点击完成后sleep的时间<br>
exception:异常发生时，如果exception为True则抛出异常，如果exception为False则不抛出异常返回False</p>
<p>example:</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> testcase.tools <span class="pl-k">import</span> <span class="pl-k">*</span>

button<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>LoginQQ<span class="pl-pds">"</span></span>)
screen_shot_click(button,<span class="pl-v">sleeptime</span><span class="pl-k">=</span><span class="pl-c1">5</span>,<span class="pl-v">exception</span><span class="pl-k">=</span><span class="pl-c1">True</span>)

screen_shot_click(<span class="pl-s"><span class="pl-pds">"</span>Attack<span class="pl-pds">"</span></span>,<span class="pl-v">sleeptime</span><span class="pl-k">=</span><span class="pl-c1">0</span>)
</pre></div>
<p>截图并标记轨迹如下所示，该部分功能仅限wetest平台测试有效：</p>
<p><a href="image/screen_mark.jpg" target="_blank"><img src="image/screen_mark.jpg" alt="Drawing" width="400px" style="max-width:100%;"></a></p>
<p><a name="9.2"></a></p>
<h2>9.2 screen_shot_click_pos 点击位置截图并记录轨迹</h2>
<p>screen_shot_click_pos与screen_shot_click的区别是，一个点击的是UI控件，一个纯粹是位置信息。操作流程两个是一致的，操作流程为截图-&gt;点击的位置标记红点-&gt;点击-&gt;sleep指定的时间。<br>
<em><code>screen_shot_click_pos(pos_x,pos_y, sleeptime=2, exception=False)</code></em><br>
pos_x:x坐标位置<br>
pos_y:y坐标位置<br>
sleeptime:点击完成后sleep的时间<br>
exception:异常发生时，如果exception为True则抛出异常，如果exception为False则不抛出异常返回False</p>
<p><a name="9.3"></a></p>
<h2>9.3 find_elment_wait查找控件直到出现位置</h2>
<p>游戏对于操作的反应时间，在不同的手机上差别可能会非常大。开始游戏登录服务器到大厅加载完成，加载过程跟网络情况、手机性能都有关系，如果仅仅使用sleep来控制的话，时间长了可能会效率低下，时间短了可能会让测试失败。所以，我们提供了find_element_wait，方便用户更加精确的控制测试进度。如，点击开始游戏后，就一直查找大厅界面的某个UI控件，查找到了也代表大厅界面加载完成了。<br>
<em><code>find_elment_wait(name, max_count=10, sleeptime=3)</code></em><br>
name:需要查找的控件名称<br>
max_count:尝试查找，调用engine.find_element的最大次数<br>
sleeptime:每次调用engine.find_element的间隔时间。max_count*sleeptime约等于最大等待市场</p>
<p>example</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> testcase.tools <span class="pl-k">import</span> <span class="pl-k">*</span>

start_game_button <span class="pl-k">=</span> find_elment_wait(<span class="pl-s"><span class="pl-pds">"</span>btnStartGame<span class="pl-pds">"</span></span>)
screen_shot_click(start_game_button, <span class="pl-c1">5</span>)

pve_btn<span class="pl-k">=</span>fine_element_wait(<span class="pl-s"><span class="pl-pds">"</span>PveBtn<span class="pl-pds">"</span></span>,<span class="pl-v">max_count</span><span class="pl-k">=</span><span class="pl-c1">20</span>,<span class="pl-v">sleeptime</span><span class="pl-k">=</span><span class="pl-c1">2</span>)
screen_shot_click(pve_btn)</pre></div>
<p>登录完成后，等待开始游戏按钮出现，点击开始游戏后游戏需要加载一段时间，直到PVE的按钮出现后点击PVE按钮。</p>
<p><a name="9.4"></a></p>
<h2>9.4 wait_for_scene等待某个场景加载完毕</h2>
<p>开始进入对局到真正进入战斗场景，通常会有一段时间，这个时候通常可以用wait_for_scene来判断是否进入。wait_for_scene与find_elment_wait的区别是，一个等待Element出现，一个是等待Scene（Unity的Scene，通过GAutomatorView能查看）出现。</p>
<p>example</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> testcase.tools <span class="pl-k">import</span> <span class="pl-k">*</span>

<span class="pl-c"><span class="pl-c">#</span>等待加载界面出现，如王者荣耀5v5匹配到后的加载界面</span>
wait_for_scene(<span class="pl-s"><span class="pl-pds">"</span>Loading<span class="pl-pds">"</span></span>, <span class="pl-v">times</span><span class="pl-k">=</span><span class="pl-c1">40</span>)

<span class="pl-c"><span class="pl-c">#</span>等待加载界面的控件已经产生</span>
find_elment_wait(<span class="pl-s"><span class="pl-pds">"</span>Form_Loading<span class="pl-pds">"</span></span>, <span class="pl-v">max_count</span><span class="pl-k">=</span><span class="pl-c1">30</span>)

<span class="pl-c"><span class="pl-c">#</span>等待加载界面的显示控件消失。不能用find_element_wait战斗场景某个控件的方式。loading的时候已经在生成element</span>
<span class="pl-k">while</span> <span class="pl-c1">True</span>:
   loading <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Form_Loading<span class="pl-pds">"</span></span>)
   <span class="pl-k">if</span> loading:
      time.sleep(<span class="pl-c1">5</span>)
   <span class="pl-k">else</span>:
      logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Load Over<span class="pl-pds">"</span></span>)
      <span class="pl-k">break</span>
</pre></div>
</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
